// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: livekit_rtc.proto

package livekit

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on SignalRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SignalRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SignalRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SignalRequestMultiError, or
// nil if none found.
func (m *SignalRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *SignalRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Message.(type) {
	case *SignalRequest_Offer:
		if v == nil {
			err := SignalRequestValidationError{
				field:  "Message",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetOffer()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SignalRequestValidationError{
						field:  "Offer",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SignalRequestValidationError{
						field:  "Offer",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetOffer()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SignalRequestValidationError{
					field:  "Offer",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *SignalRequest_Answer:
		if v == nil {
			err := SignalRequestValidationError{
				field:  "Message",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetAnswer()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SignalRequestValidationError{
						field:  "Answer",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SignalRequestValidationError{
						field:  "Answer",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAnswer()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SignalRequestValidationError{
					field:  "Answer",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *SignalRequest_Trickle:
		if v == nil {
			err := SignalRequestValidationError{
				field:  "Message",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetTrickle()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SignalRequestValidationError{
						field:  "Trickle",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SignalRequestValidationError{
						field:  "Trickle",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTrickle()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SignalRequestValidationError{
					field:  "Trickle",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *SignalRequest_AddTrack:
		if v == nil {
			err := SignalRequestValidationError{
				field:  "Message",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetAddTrack()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SignalRequestValidationError{
						field:  "AddTrack",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SignalRequestValidationError{
						field:  "AddTrack",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAddTrack()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SignalRequestValidationError{
					field:  "AddTrack",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *SignalRequest_Mute:
		if v == nil {
			err := SignalRequestValidationError{
				field:  "Message",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetMute()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SignalRequestValidationError{
						field:  "Mute",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SignalRequestValidationError{
						field:  "Mute",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetMute()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SignalRequestValidationError{
					field:  "Mute",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *SignalRequest_Subscription:
		if v == nil {
			err := SignalRequestValidationError{
				field:  "Message",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetSubscription()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SignalRequestValidationError{
						field:  "Subscription",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SignalRequestValidationError{
						field:  "Subscription",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSubscription()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SignalRequestValidationError{
					field:  "Subscription",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *SignalRequest_TrackSetting:
		if v == nil {
			err := SignalRequestValidationError{
				field:  "Message",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetTrackSetting()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SignalRequestValidationError{
						field:  "TrackSetting",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SignalRequestValidationError{
						field:  "TrackSetting",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTrackSetting()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SignalRequestValidationError{
					field:  "TrackSetting",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *SignalRequest_Leave:
		if v == nil {
			err := SignalRequestValidationError{
				field:  "Message",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetLeave()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SignalRequestValidationError{
						field:  "Leave",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SignalRequestValidationError{
						field:  "Leave",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetLeave()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SignalRequestValidationError{
					field:  "Leave",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *SignalRequest_UpdateLayers:
		if v == nil {
			err := SignalRequestValidationError{
				field:  "Message",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetUpdateLayers()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SignalRequestValidationError{
						field:  "UpdateLayers",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SignalRequestValidationError{
						field:  "UpdateLayers",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetUpdateLayers()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SignalRequestValidationError{
					field:  "UpdateLayers",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *SignalRequest_SubscriptionPermission:
		if v == nil {
			err := SignalRequestValidationError{
				field:  "Message",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetSubscriptionPermission()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SignalRequestValidationError{
						field:  "SubscriptionPermission",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SignalRequestValidationError{
						field:  "SubscriptionPermission",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSubscriptionPermission()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SignalRequestValidationError{
					field:  "SubscriptionPermission",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *SignalRequest_SyncState:
		if v == nil {
			err := SignalRequestValidationError{
				field:  "Message",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetSyncState()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SignalRequestValidationError{
						field:  "SyncState",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SignalRequestValidationError{
						field:  "SyncState",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSyncState()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SignalRequestValidationError{
					field:  "SyncState",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *SignalRequest_Simulate:
		if v == nil {
			err := SignalRequestValidationError{
				field:  "Message",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetSimulate()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SignalRequestValidationError{
						field:  "Simulate",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SignalRequestValidationError{
						field:  "Simulate",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSimulate()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SignalRequestValidationError{
					field:  "Simulate",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *SignalRequest_Ping:
		if v == nil {
			err := SignalRequestValidationError{
				field:  "Message",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for Ping
	case *SignalRequest_UpdateMetadata:
		if v == nil {
			err := SignalRequestValidationError{
				field:  "Message",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetUpdateMetadata()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SignalRequestValidationError{
						field:  "UpdateMetadata",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SignalRequestValidationError{
						field:  "UpdateMetadata",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetUpdateMetadata()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SignalRequestValidationError{
					field:  "UpdateMetadata",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *SignalRequest_PingReq:
		if v == nil {
			err := SignalRequestValidationError{
				field:  "Message",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetPingReq()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SignalRequestValidationError{
						field:  "PingReq",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SignalRequestValidationError{
						field:  "PingReq",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetPingReq()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SignalRequestValidationError{
					field:  "PingReq",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *SignalRequest_UpdateAudioTrack:
		if v == nil {
			err := SignalRequestValidationError{
				field:  "Message",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetUpdateAudioTrack()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SignalRequestValidationError{
						field:  "UpdateAudioTrack",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SignalRequestValidationError{
						field:  "UpdateAudioTrack",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetUpdateAudioTrack()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SignalRequestValidationError{
					field:  "UpdateAudioTrack",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *SignalRequest_UpdateVideoTrack:
		if v == nil {
			err := SignalRequestValidationError{
				field:  "Message",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetUpdateVideoTrack()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SignalRequestValidationError{
						field:  "UpdateVideoTrack",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SignalRequestValidationError{
						field:  "UpdateVideoTrack",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetUpdateVideoTrack()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SignalRequestValidationError{
					field:  "UpdateVideoTrack",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return SignalRequestMultiError(errors)
	}

	return nil
}

// SignalRequestMultiError is an error wrapping multiple validation errors
// returned by SignalRequest.ValidateAll() if the designated constraints
// aren't met.
type SignalRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SignalRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SignalRequestMultiError) AllErrors() []error { return m }

// SignalRequestValidationError is the validation error returned by
// SignalRequest.Validate if the designated constraints aren't met.
type SignalRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SignalRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SignalRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SignalRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SignalRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SignalRequestValidationError) ErrorName() string { return "SignalRequestValidationError" }

// Error satisfies the builtin error interface
func (e SignalRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSignalRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SignalRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SignalRequestValidationError{}

// Validate checks the field values on SignalResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SignalResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SignalResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SignalResponseMultiError,
// or nil if none found.
func (m *SignalResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *SignalResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Message.(type) {
	case *SignalResponse_Join:
		if v == nil {
			err := SignalResponseValidationError{
				field:  "Message",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetJoin()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SignalResponseValidationError{
						field:  "Join",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SignalResponseValidationError{
						field:  "Join",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetJoin()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SignalResponseValidationError{
					field:  "Join",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *SignalResponse_Answer:
		if v == nil {
			err := SignalResponseValidationError{
				field:  "Message",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetAnswer()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SignalResponseValidationError{
						field:  "Answer",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SignalResponseValidationError{
						field:  "Answer",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAnswer()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SignalResponseValidationError{
					field:  "Answer",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *SignalResponse_Offer:
		if v == nil {
			err := SignalResponseValidationError{
				field:  "Message",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetOffer()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SignalResponseValidationError{
						field:  "Offer",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SignalResponseValidationError{
						field:  "Offer",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetOffer()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SignalResponseValidationError{
					field:  "Offer",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *SignalResponse_Trickle:
		if v == nil {
			err := SignalResponseValidationError{
				field:  "Message",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetTrickle()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SignalResponseValidationError{
						field:  "Trickle",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SignalResponseValidationError{
						field:  "Trickle",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTrickle()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SignalResponseValidationError{
					field:  "Trickle",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *SignalResponse_Update:
		if v == nil {
			err := SignalResponseValidationError{
				field:  "Message",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetUpdate()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SignalResponseValidationError{
						field:  "Update",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SignalResponseValidationError{
						field:  "Update",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetUpdate()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SignalResponseValidationError{
					field:  "Update",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *SignalResponse_TrackPublished:
		if v == nil {
			err := SignalResponseValidationError{
				field:  "Message",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetTrackPublished()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SignalResponseValidationError{
						field:  "TrackPublished",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SignalResponseValidationError{
						field:  "TrackPublished",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTrackPublished()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SignalResponseValidationError{
					field:  "TrackPublished",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *SignalResponse_Leave:
		if v == nil {
			err := SignalResponseValidationError{
				field:  "Message",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetLeave()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SignalResponseValidationError{
						field:  "Leave",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SignalResponseValidationError{
						field:  "Leave",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetLeave()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SignalResponseValidationError{
					field:  "Leave",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *SignalResponse_Mute:
		if v == nil {
			err := SignalResponseValidationError{
				field:  "Message",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetMute()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SignalResponseValidationError{
						field:  "Mute",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SignalResponseValidationError{
						field:  "Mute",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetMute()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SignalResponseValidationError{
					field:  "Mute",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *SignalResponse_SpeakersChanged:
		if v == nil {
			err := SignalResponseValidationError{
				field:  "Message",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetSpeakersChanged()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SignalResponseValidationError{
						field:  "SpeakersChanged",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SignalResponseValidationError{
						field:  "SpeakersChanged",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSpeakersChanged()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SignalResponseValidationError{
					field:  "SpeakersChanged",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *SignalResponse_RoomUpdate:
		if v == nil {
			err := SignalResponseValidationError{
				field:  "Message",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetRoomUpdate()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SignalResponseValidationError{
						field:  "RoomUpdate",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SignalResponseValidationError{
						field:  "RoomUpdate",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRoomUpdate()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SignalResponseValidationError{
					field:  "RoomUpdate",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *SignalResponse_ConnectionQuality:
		if v == nil {
			err := SignalResponseValidationError{
				field:  "Message",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetConnectionQuality()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SignalResponseValidationError{
						field:  "ConnectionQuality",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SignalResponseValidationError{
						field:  "ConnectionQuality",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetConnectionQuality()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SignalResponseValidationError{
					field:  "ConnectionQuality",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *SignalResponse_StreamStateUpdate:
		if v == nil {
			err := SignalResponseValidationError{
				field:  "Message",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetStreamStateUpdate()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SignalResponseValidationError{
						field:  "StreamStateUpdate",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SignalResponseValidationError{
						field:  "StreamStateUpdate",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetStreamStateUpdate()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SignalResponseValidationError{
					field:  "StreamStateUpdate",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *SignalResponse_SubscribedQualityUpdate:
		if v == nil {
			err := SignalResponseValidationError{
				field:  "Message",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetSubscribedQualityUpdate()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SignalResponseValidationError{
						field:  "SubscribedQualityUpdate",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SignalResponseValidationError{
						field:  "SubscribedQualityUpdate",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSubscribedQualityUpdate()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SignalResponseValidationError{
					field:  "SubscribedQualityUpdate",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *SignalResponse_SubscriptionPermissionUpdate:
		if v == nil {
			err := SignalResponseValidationError{
				field:  "Message",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetSubscriptionPermissionUpdate()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SignalResponseValidationError{
						field:  "SubscriptionPermissionUpdate",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SignalResponseValidationError{
						field:  "SubscriptionPermissionUpdate",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSubscriptionPermissionUpdate()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SignalResponseValidationError{
					field:  "SubscriptionPermissionUpdate",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *SignalResponse_RefreshToken:
		if v == nil {
			err := SignalResponseValidationError{
				field:  "Message",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for RefreshToken
	case *SignalResponse_TrackUnpublished:
		if v == nil {
			err := SignalResponseValidationError{
				field:  "Message",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetTrackUnpublished()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SignalResponseValidationError{
						field:  "TrackUnpublished",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SignalResponseValidationError{
						field:  "TrackUnpublished",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTrackUnpublished()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SignalResponseValidationError{
					field:  "TrackUnpublished",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *SignalResponse_Pong:
		if v == nil {
			err := SignalResponseValidationError{
				field:  "Message",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for Pong
	case *SignalResponse_Reconnect:
		if v == nil {
			err := SignalResponseValidationError{
				field:  "Message",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetReconnect()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SignalResponseValidationError{
						field:  "Reconnect",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SignalResponseValidationError{
						field:  "Reconnect",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetReconnect()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SignalResponseValidationError{
					field:  "Reconnect",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *SignalResponse_PongResp:
		if v == nil {
			err := SignalResponseValidationError{
				field:  "Message",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetPongResp()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SignalResponseValidationError{
						field:  "PongResp",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SignalResponseValidationError{
						field:  "PongResp",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetPongResp()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SignalResponseValidationError{
					field:  "PongResp",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *SignalResponse_SubscriptionResponse:
		if v == nil {
			err := SignalResponseValidationError{
				field:  "Message",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetSubscriptionResponse()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SignalResponseValidationError{
						field:  "SubscriptionResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SignalResponseValidationError{
						field:  "SubscriptionResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSubscriptionResponse()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SignalResponseValidationError{
					field:  "SubscriptionResponse",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *SignalResponse_RequestResponse:
		if v == nil {
			err := SignalResponseValidationError{
				field:  "Message",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetRequestResponse()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SignalResponseValidationError{
						field:  "RequestResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SignalResponseValidationError{
						field:  "RequestResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRequestResponse()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SignalResponseValidationError{
					field:  "RequestResponse",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *SignalResponse_TrackSubscribed:
		if v == nil {
			err := SignalResponseValidationError{
				field:  "Message",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetTrackSubscribed()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SignalResponseValidationError{
						field:  "TrackSubscribed",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SignalResponseValidationError{
						field:  "TrackSubscribed",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTrackSubscribed()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SignalResponseValidationError{
					field:  "TrackSubscribed",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return SignalResponseMultiError(errors)
	}

	return nil
}

// SignalResponseMultiError is an error wrapping multiple validation errors
// returned by SignalResponse.ValidateAll() if the designated constraints
// aren't met.
type SignalResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SignalResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SignalResponseMultiError) AllErrors() []error { return m }

// SignalResponseValidationError is the validation error returned by
// SignalResponse.Validate if the designated constraints aren't met.
type SignalResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SignalResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SignalResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SignalResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SignalResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SignalResponseValidationError) ErrorName() string { return "SignalResponseValidationError" }

// Error satisfies the builtin error interface
func (e SignalResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSignalResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SignalResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SignalResponseValidationError{}

// Validate checks the field values on SimulcastCodec with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SimulcastCodec) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SimulcastCodec with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SimulcastCodecMultiError,
// or nil if none found.
func (m *SimulcastCodec) ValidateAll() error {
	return m.validate(true)
}

func (m *SimulcastCodec) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Codec

	// no validation rules for Cid

	if len(errors) > 0 {
		return SimulcastCodecMultiError(errors)
	}

	return nil
}

// SimulcastCodecMultiError is an error wrapping multiple validation errors
// returned by SimulcastCodec.ValidateAll() if the designated constraints
// aren't met.
type SimulcastCodecMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SimulcastCodecMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SimulcastCodecMultiError) AllErrors() []error { return m }

// SimulcastCodecValidationError is the validation error returned by
// SimulcastCodec.Validate if the designated constraints aren't met.
type SimulcastCodecValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SimulcastCodecValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SimulcastCodecValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SimulcastCodecValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SimulcastCodecValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SimulcastCodecValidationError) ErrorName() string { return "SimulcastCodecValidationError" }

// Error satisfies the builtin error interface
func (e SimulcastCodecValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSimulcastCodec.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SimulcastCodecValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SimulcastCodecValidationError{}

// Validate checks the field values on AddTrackRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *AddTrackRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AddTrackRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AddTrackRequestMultiError, or nil if none found.
func (m *AddTrackRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *AddTrackRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Cid

	// no validation rules for Name

	// no validation rules for Type

	// no validation rules for Width

	// no validation rules for Height

	// no validation rules for Muted

	// no validation rules for DisableDtx

	// no validation rules for Source

	for idx, item := range m.GetLayers() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AddTrackRequestValidationError{
						field:  fmt.Sprintf("Layers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AddTrackRequestValidationError{
						field:  fmt.Sprintf("Layers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AddTrackRequestValidationError{
					field:  fmt.Sprintf("Layers[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetSimulcastCodecs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AddTrackRequestValidationError{
						field:  fmt.Sprintf("SimulcastCodecs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AddTrackRequestValidationError{
						field:  fmt.Sprintf("SimulcastCodecs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AddTrackRequestValidationError{
					field:  fmt.Sprintf("SimulcastCodecs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Sid

	// no validation rules for Stereo

	// no validation rules for DisableRed

	// no validation rules for Encryption

	// no validation rules for Stream

	if len(errors) > 0 {
		return AddTrackRequestMultiError(errors)
	}

	return nil
}

// AddTrackRequestMultiError is an error wrapping multiple validation errors
// returned by AddTrackRequest.ValidateAll() if the designated constraints
// aren't met.
type AddTrackRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AddTrackRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AddTrackRequestMultiError) AllErrors() []error { return m }

// AddTrackRequestValidationError is the validation error returned by
// AddTrackRequest.Validate if the designated constraints aren't met.
type AddTrackRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AddTrackRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AddTrackRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AddTrackRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AddTrackRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AddTrackRequestValidationError) ErrorName() string { return "AddTrackRequestValidationError" }

// Error satisfies the builtin error interface
func (e AddTrackRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAddTrackRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AddTrackRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AddTrackRequestValidationError{}

// Validate checks the field values on TrickleRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TrickleRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TrickleRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TrickleRequestMultiError,
// or nil if none found.
func (m *TrickleRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *TrickleRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CandidateInit

	// no validation rules for Target

	// no validation rules for Final

	if len(errors) > 0 {
		return TrickleRequestMultiError(errors)
	}

	return nil
}

// TrickleRequestMultiError is an error wrapping multiple validation errors
// returned by TrickleRequest.ValidateAll() if the designated constraints
// aren't met.
type TrickleRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TrickleRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TrickleRequestMultiError) AllErrors() []error { return m }

// TrickleRequestValidationError is the validation error returned by
// TrickleRequest.Validate if the designated constraints aren't met.
type TrickleRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TrickleRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TrickleRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TrickleRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TrickleRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TrickleRequestValidationError) ErrorName() string { return "TrickleRequestValidationError" }

// Error satisfies the builtin error interface
func (e TrickleRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTrickleRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TrickleRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TrickleRequestValidationError{}

// Validate checks the field values on MuteTrackRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *MuteTrackRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MuteTrackRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MuteTrackRequestMultiError, or nil if none found.
func (m *MuteTrackRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *MuteTrackRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Sid

	// no validation rules for Muted

	if len(errors) > 0 {
		return MuteTrackRequestMultiError(errors)
	}

	return nil
}

// MuteTrackRequestMultiError is an error wrapping multiple validation errors
// returned by MuteTrackRequest.ValidateAll() if the designated constraints
// aren't met.
type MuteTrackRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MuteTrackRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MuteTrackRequestMultiError) AllErrors() []error { return m }

// MuteTrackRequestValidationError is the validation error returned by
// MuteTrackRequest.Validate if the designated constraints aren't met.
type MuteTrackRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MuteTrackRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MuteTrackRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MuteTrackRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MuteTrackRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MuteTrackRequestValidationError) ErrorName() string { return "MuteTrackRequestValidationError" }

// Error satisfies the builtin error interface
func (e MuteTrackRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMuteTrackRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MuteTrackRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MuteTrackRequestValidationError{}

// Validate checks the field values on JoinResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *JoinResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on JoinResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in JoinResponseMultiError, or
// nil if none found.
func (m *JoinResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *JoinResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetRoom()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, JoinResponseValidationError{
					field:  "Room",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, JoinResponseValidationError{
					field:  "Room",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRoom()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return JoinResponseValidationError{
				field:  "Room",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetParticipant()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, JoinResponseValidationError{
					field:  "Participant",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, JoinResponseValidationError{
					field:  "Participant",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetParticipant()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return JoinResponseValidationError{
				field:  "Participant",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetOtherParticipants() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, JoinResponseValidationError{
						field:  fmt.Sprintf("OtherParticipants[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, JoinResponseValidationError{
						field:  fmt.Sprintf("OtherParticipants[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return JoinResponseValidationError{
					field:  fmt.Sprintf("OtherParticipants[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for ServerVersion

	for idx, item := range m.GetIceServers() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, JoinResponseValidationError{
						field:  fmt.Sprintf("IceServers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, JoinResponseValidationError{
						field:  fmt.Sprintf("IceServers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return JoinResponseValidationError{
					field:  fmt.Sprintf("IceServers[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for SubscriberPrimary

	// no validation rules for AlternativeUrl

	if all {
		switch v := interface{}(m.GetClientConfiguration()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, JoinResponseValidationError{
					field:  "ClientConfiguration",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, JoinResponseValidationError{
					field:  "ClientConfiguration",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetClientConfiguration()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return JoinResponseValidationError{
				field:  "ClientConfiguration",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ServerRegion

	// no validation rules for PingTimeout

	// no validation rules for PingInterval

	if all {
		switch v := interface{}(m.GetServerInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, JoinResponseValidationError{
					field:  "ServerInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, JoinResponseValidationError{
					field:  "ServerInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetServerInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return JoinResponseValidationError{
				field:  "ServerInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for SifTrailer

	for idx, item := range m.GetEnabledPublishCodecs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, JoinResponseValidationError{
						field:  fmt.Sprintf("EnabledPublishCodecs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, JoinResponseValidationError{
						field:  fmt.Sprintf("EnabledPublishCodecs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return JoinResponseValidationError{
					field:  fmt.Sprintf("EnabledPublishCodecs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return JoinResponseMultiError(errors)
	}

	return nil
}

// JoinResponseMultiError is an error wrapping multiple validation errors
// returned by JoinResponse.ValidateAll() if the designated constraints aren't met.
type JoinResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m JoinResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m JoinResponseMultiError) AllErrors() []error { return m }

// JoinResponseValidationError is the validation error returned by
// JoinResponse.Validate if the designated constraints aren't met.
type JoinResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e JoinResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e JoinResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e JoinResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e JoinResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e JoinResponseValidationError) ErrorName() string { return "JoinResponseValidationError" }

// Error satisfies the builtin error interface
func (e JoinResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sJoinResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = JoinResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = JoinResponseValidationError{}

// Validate checks the field values on ReconnectResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ReconnectResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReconnectResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReconnectResponseMultiError, or nil if none found.
func (m *ReconnectResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ReconnectResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetIceServers() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ReconnectResponseValidationError{
						field:  fmt.Sprintf("IceServers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ReconnectResponseValidationError{
						field:  fmt.Sprintf("IceServers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ReconnectResponseValidationError{
					field:  fmt.Sprintf("IceServers[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetClientConfiguration()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReconnectResponseValidationError{
					field:  "ClientConfiguration",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReconnectResponseValidationError{
					field:  "ClientConfiguration",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetClientConfiguration()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReconnectResponseValidationError{
				field:  "ClientConfiguration",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ReconnectResponseMultiError(errors)
	}

	return nil
}

// ReconnectResponseMultiError is an error wrapping multiple validation errors
// returned by ReconnectResponse.ValidateAll() if the designated constraints
// aren't met.
type ReconnectResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReconnectResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReconnectResponseMultiError) AllErrors() []error { return m }

// ReconnectResponseValidationError is the validation error returned by
// ReconnectResponse.Validate if the designated constraints aren't met.
type ReconnectResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReconnectResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReconnectResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReconnectResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReconnectResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReconnectResponseValidationError) ErrorName() string {
	return "ReconnectResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ReconnectResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReconnectResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReconnectResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReconnectResponseValidationError{}

// Validate checks the field values on TrackPublishedResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TrackPublishedResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TrackPublishedResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TrackPublishedResponseMultiError, or nil if none found.
func (m *TrackPublishedResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *TrackPublishedResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Cid

	if all {
		switch v := interface{}(m.GetTrack()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TrackPublishedResponseValidationError{
					field:  "Track",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TrackPublishedResponseValidationError{
					field:  "Track",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTrack()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TrackPublishedResponseValidationError{
				field:  "Track",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return TrackPublishedResponseMultiError(errors)
	}

	return nil
}

// TrackPublishedResponseMultiError is an error wrapping multiple validation
// errors returned by TrackPublishedResponse.ValidateAll() if the designated
// constraints aren't met.
type TrackPublishedResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TrackPublishedResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TrackPublishedResponseMultiError) AllErrors() []error { return m }

// TrackPublishedResponseValidationError is the validation error returned by
// TrackPublishedResponse.Validate if the designated constraints aren't met.
type TrackPublishedResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TrackPublishedResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TrackPublishedResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TrackPublishedResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TrackPublishedResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TrackPublishedResponseValidationError) ErrorName() string {
	return "TrackPublishedResponseValidationError"
}

// Error satisfies the builtin error interface
func (e TrackPublishedResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTrackPublishedResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TrackPublishedResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TrackPublishedResponseValidationError{}

// Validate checks the field values on TrackUnpublishedResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TrackUnpublishedResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TrackUnpublishedResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TrackUnpublishedResponseMultiError, or nil if none found.
func (m *TrackUnpublishedResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *TrackUnpublishedResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TrackSid

	if len(errors) > 0 {
		return TrackUnpublishedResponseMultiError(errors)
	}

	return nil
}

// TrackUnpublishedResponseMultiError is an error wrapping multiple validation
// errors returned by TrackUnpublishedResponse.ValidateAll() if the designated
// constraints aren't met.
type TrackUnpublishedResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TrackUnpublishedResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TrackUnpublishedResponseMultiError) AllErrors() []error { return m }

// TrackUnpublishedResponseValidationError is the validation error returned by
// TrackUnpublishedResponse.Validate if the designated constraints aren't met.
type TrackUnpublishedResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TrackUnpublishedResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TrackUnpublishedResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TrackUnpublishedResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TrackUnpublishedResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TrackUnpublishedResponseValidationError) ErrorName() string {
	return "TrackUnpublishedResponseValidationError"
}

// Error satisfies the builtin error interface
func (e TrackUnpublishedResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTrackUnpublishedResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TrackUnpublishedResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TrackUnpublishedResponseValidationError{}

// Validate checks the field values on SessionDescription with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SessionDescription) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SessionDescription with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SessionDescriptionMultiError, or nil if none found.
func (m *SessionDescription) ValidateAll() error {
	return m.validate(true)
}

func (m *SessionDescription) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Type

	// no validation rules for Sdp

	if len(errors) > 0 {
		return SessionDescriptionMultiError(errors)
	}

	return nil
}

// SessionDescriptionMultiError is an error wrapping multiple validation errors
// returned by SessionDescription.ValidateAll() if the designated constraints
// aren't met.
type SessionDescriptionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SessionDescriptionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SessionDescriptionMultiError) AllErrors() []error { return m }

// SessionDescriptionValidationError is the validation error returned by
// SessionDescription.Validate if the designated constraints aren't met.
type SessionDescriptionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SessionDescriptionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SessionDescriptionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SessionDescriptionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SessionDescriptionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SessionDescriptionValidationError) ErrorName() string {
	return "SessionDescriptionValidationError"
}

// Error satisfies the builtin error interface
func (e SessionDescriptionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSessionDescription.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SessionDescriptionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SessionDescriptionValidationError{}

// Validate checks the field values on ParticipantUpdate with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ParticipantUpdate) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ParticipantUpdate with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ParticipantUpdateMultiError, or nil if none found.
func (m *ParticipantUpdate) ValidateAll() error {
	return m.validate(true)
}

func (m *ParticipantUpdate) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetParticipants() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ParticipantUpdateValidationError{
						field:  fmt.Sprintf("Participants[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ParticipantUpdateValidationError{
						field:  fmt.Sprintf("Participants[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ParticipantUpdateValidationError{
					field:  fmt.Sprintf("Participants[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ParticipantUpdateMultiError(errors)
	}

	return nil
}

// ParticipantUpdateMultiError is an error wrapping multiple validation errors
// returned by ParticipantUpdate.ValidateAll() if the designated constraints
// aren't met.
type ParticipantUpdateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ParticipantUpdateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ParticipantUpdateMultiError) AllErrors() []error { return m }

// ParticipantUpdateValidationError is the validation error returned by
// ParticipantUpdate.Validate if the designated constraints aren't met.
type ParticipantUpdateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ParticipantUpdateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ParticipantUpdateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ParticipantUpdateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ParticipantUpdateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ParticipantUpdateValidationError) ErrorName() string {
	return "ParticipantUpdateValidationError"
}

// Error satisfies the builtin error interface
func (e ParticipantUpdateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sParticipantUpdate.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ParticipantUpdateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ParticipantUpdateValidationError{}

// Validate checks the field values on UpdateSubscription with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateSubscription) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateSubscription with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateSubscriptionMultiError, or nil if none found.
func (m *UpdateSubscription) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateSubscription) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Subscribe

	for idx, item := range m.GetParticipantTracks() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UpdateSubscriptionValidationError{
						field:  fmt.Sprintf("ParticipantTracks[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UpdateSubscriptionValidationError{
						field:  fmt.Sprintf("ParticipantTracks[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UpdateSubscriptionValidationError{
					field:  fmt.Sprintf("ParticipantTracks[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return UpdateSubscriptionMultiError(errors)
	}

	return nil
}

// UpdateSubscriptionMultiError is an error wrapping multiple validation errors
// returned by UpdateSubscription.ValidateAll() if the designated constraints
// aren't met.
type UpdateSubscriptionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateSubscriptionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateSubscriptionMultiError) AllErrors() []error { return m }

// UpdateSubscriptionValidationError is the validation error returned by
// UpdateSubscription.Validate if the designated constraints aren't met.
type UpdateSubscriptionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateSubscriptionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateSubscriptionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateSubscriptionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateSubscriptionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateSubscriptionValidationError) ErrorName() string {
	return "UpdateSubscriptionValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateSubscriptionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateSubscription.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateSubscriptionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateSubscriptionValidationError{}

// Validate checks the field values on UpdateTrackSettings with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateTrackSettings) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateTrackSettings with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateTrackSettingsMultiError, or nil if none found.
func (m *UpdateTrackSettings) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateTrackSettings) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Disabled

	// no validation rules for Quality

	// no validation rules for Width

	// no validation rules for Height

	// no validation rules for Fps

	// no validation rules for Priority

	if len(errors) > 0 {
		return UpdateTrackSettingsMultiError(errors)
	}

	return nil
}

// UpdateTrackSettingsMultiError is an error wrapping multiple validation
// errors returned by UpdateTrackSettings.ValidateAll() if the designated
// constraints aren't met.
type UpdateTrackSettingsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateTrackSettingsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateTrackSettingsMultiError) AllErrors() []error { return m }

// UpdateTrackSettingsValidationError is the validation error returned by
// UpdateTrackSettings.Validate if the designated constraints aren't met.
type UpdateTrackSettingsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateTrackSettingsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateTrackSettingsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateTrackSettingsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateTrackSettingsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateTrackSettingsValidationError) ErrorName() string {
	return "UpdateTrackSettingsValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateTrackSettingsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateTrackSettings.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateTrackSettingsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateTrackSettingsValidationError{}

// Validate checks the field values on UpdateLocalAudioTrack with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateLocalAudioTrack) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateLocalAudioTrack with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateLocalAudioTrackMultiError, or nil if none found.
func (m *UpdateLocalAudioTrack) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateLocalAudioTrack) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TrackSid

	if len(errors) > 0 {
		return UpdateLocalAudioTrackMultiError(errors)
	}

	return nil
}

// UpdateLocalAudioTrackMultiError is an error wrapping multiple validation
// errors returned by UpdateLocalAudioTrack.ValidateAll() if the designated
// constraints aren't met.
type UpdateLocalAudioTrackMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateLocalAudioTrackMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateLocalAudioTrackMultiError) AllErrors() []error { return m }

// UpdateLocalAudioTrackValidationError is the validation error returned by
// UpdateLocalAudioTrack.Validate if the designated constraints aren't met.
type UpdateLocalAudioTrackValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateLocalAudioTrackValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateLocalAudioTrackValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateLocalAudioTrackValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateLocalAudioTrackValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateLocalAudioTrackValidationError) ErrorName() string {
	return "UpdateLocalAudioTrackValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateLocalAudioTrackValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateLocalAudioTrack.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateLocalAudioTrackValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateLocalAudioTrackValidationError{}

// Validate checks the field values on UpdateLocalVideoTrack with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateLocalVideoTrack) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateLocalVideoTrack with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateLocalVideoTrackMultiError, or nil if none found.
func (m *UpdateLocalVideoTrack) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateLocalVideoTrack) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TrackSid

	// no validation rules for Width

	// no validation rules for Height

	if len(errors) > 0 {
		return UpdateLocalVideoTrackMultiError(errors)
	}

	return nil
}

// UpdateLocalVideoTrackMultiError is an error wrapping multiple validation
// errors returned by UpdateLocalVideoTrack.ValidateAll() if the designated
// constraints aren't met.
type UpdateLocalVideoTrackMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateLocalVideoTrackMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateLocalVideoTrackMultiError) AllErrors() []error { return m }

// UpdateLocalVideoTrackValidationError is the validation error returned by
// UpdateLocalVideoTrack.Validate if the designated constraints aren't met.
type UpdateLocalVideoTrackValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateLocalVideoTrackValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateLocalVideoTrackValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateLocalVideoTrackValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateLocalVideoTrackValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateLocalVideoTrackValidationError) ErrorName() string {
	return "UpdateLocalVideoTrackValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateLocalVideoTrackValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateLocalVideoTrack.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateLocalVideoTrackValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateLocalVideoTrackValidationError{}

// Validate checks the field values on LeaveRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *LeaveRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LeaveRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in LeaveRequestMultiError, or
// nil if none found.
func (m *LeaveRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *LeaveRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CanReconnect

	// no validation rules for Reason

	// no validation rules for Action

	if all {
		switch v := interface{}(m.GetRegions()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LeaveRequestValidationError{
					field:  "Regions",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LeaveRequestValidationError{
					field:  "Regions",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRegions()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LeaveRequestValidationError{
				field:  "Regions",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return LeaveRequestMultiError(errors)
	}

	return nil
}

// LeaveRequestMultiError is an error wrapping multiple validation errors
// returned by LeaveRequest.ValidateAll() if the designated constraints aren't met.
type LeaveRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LeaveRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LeaveRequestMultiError) AllErrors() []error { return m }

// LeaveRequestValidationError is the validation error returned by
// LeaveRequest.Validate if the designated constraints aren't met.
type LeaveRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LeaveRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LeaveRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LeaveRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LeaveRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LeaveRequestValidationError) ErrorName() string { return "LeaveRequestValidationError" }

// Error satisfies the builtin error interface
func (e LeaveRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLeaveRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LeaveRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LeaveRequestValidationError{}

// Validate checks the field values on UpdateVideoLayers with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *UpdateVideoLayers) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateVideoLayers with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateVideoLayersMultiError, or nil if none found.
func (m *UpdateVideoLayers) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateVideoLayers) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TrackSid

	for idx, item := range m.GetLayers() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UpdateVideoLayersValidationError{
						field:  fmt.Sprintf("Layers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UpdateVideoLayersValidationError{
						field:  fmt.Sprintf("Layers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UpdateVideoLayersValidationError{
					field:  fmt.Sprintf("Layers[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return UpdateVideoLayersMultiError(errors)
	}

	return nil
}

// UpdateVideoLayersMultiError is an error wrapping multiple validation errors
// returned by UpdateVideoLayers.ValidateAll() if the designated constraints
// aren't met.
type UpdateVideoLayersMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateVideoLayersMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateVideoLayersMultiError) AllErrors() []error { return m }

// UpdateVideoLayersValidationError is the validation error returned by
// UpdateVideoLayers.Validate if the designated constraints aren't met.
type UpdateVideoLayersValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateVideoLayersValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateVideoLayersValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateVideoLayersValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateVideoLayersValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateVideoLayersValidationError) ErrorName() string {
	return "UpdateVideoLayersValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateVideoLayersValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateVideoLayers.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateVideoLayersValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateVideoLayersValidationError{}

// Validate checks the field values on UpdateParticipantMetadata with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateParticipantMetadata) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateParticipantMetadata with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateParticipantMetadataMultiError, or nil if none found.
func (m *UpdateParticipantMetadata) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateParticipantMetadata) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Metadata

	// no validation rules for Name

	// no validation rules for Attributes

	// no validation rules for RequestId

	if len(errors) > 0 {
		return UpdateParticipantMetadataMultiError(errors)
	}

	return nil
}

// UpdateParticipantMetadataMultiError is an error wrapping multiple validation
// errors returned by UpdateParticipantMetadata.ValidateAll() if the
// designated constraints aren't met.
type UpdateParticipantMetadataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateParticipantMetadataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateParticipantMetadataMultiError) AllErrors() []error { return m }

// UpdateParticipantMetadataValidationError is the validation error returned by
// UpdateParticipantMetadata.Validate if the designated constraints aren't met.
type UpdateParticipantMetadataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateParticipantMetadataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateParticipantMetadataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateParticipantMetadataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateParticipantMetadataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateParticipantMetadataValidationError) ErrorName() string {
	return "UpdateParticipantMetadataValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateParticipantMetadataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateParticipantMetadata.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateParticipantMetadataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateParticipantMetadataValidationError{}

// Validate checks the field values on ICEServer with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ICEServer) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ICEServer with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ICEServerMultiError, or nil
// if none found.
func (m *ICEServer) ValidateAll() error {
	return m.validate(true)
}

func (m *ICEServer) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Username

	// no validation rules for Credential

	if len(errors) > 0 {
		return ICEServerMultiError(errors)
	}

	return nil
}

// ICEServerMultiError is an error wrapping multiple validation errors returned
// by ICEServer.ValidateAll() if the designated constraints aren't met.
type ICEServerMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ICEServerMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ICEServerMultiError) AllErrors() []error { return m }

// ICEServerValidationError is the validation error returned by
// ICEServer.Validate if the designated constraints aren't met.
type ICEServerValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ICEServerValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ICEServerValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ICEServerValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ICEServerValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ICEServerValidationError) ErrorName() string { return "ICEServerValidationError" }

// Error satisfies the builtin error interface
func (e ICEServerValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sICEServer.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ICEServerValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ICEServerValidationError{}

// Validate checks the field values on SpeakersChanged with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *SpeakersChanged) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SpeakersChanged with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SpeakersChangedMultiError, or nil if none found.
func (m *SpeakersChanged) ValidateAll() error {
	return m.validate(true)
}

func (m *SpeakersChanged) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetSpeakers() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SpeakersChangedValidationError{
						field:  fmt.Sprintf("Speakers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SpeakersChangedValidationError{
						field:  fmt.Sprintf("Speakers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SpeakersChangedValidationError{
					field:  fmt.Sprintf("Speakers[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return SpeakersChangedMultiError(errors)
	}

	return nil
}

// SpeakersChangedMultiError is an error wrapping multiple validation errors
// returned by SpeakersChanged.ValidateAll() if the designated constraints
// aren't met.
type SpeakersChangedMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SpeakersChangedMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SpeakersChangedMultiError) AllErrors() []error { return m }

// SpeakersChangedValidationError is the validation error returned by
// SpeakersChanged.Validate if the designated constraints aren't met.
type SpeakersChangedValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SpeakersChangedValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SpeakersChangedValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SpeakersChangedValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SpeakersChangedValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SpeakersChangedValidationError) ErrorName() string { return "SpeakersChangedValidationError" }

// Error satisfies the builtin error interface
func (e SpeakersChangedValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSpeakersChanged.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SpeakersChangedValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SpeakersChangedValidationError{}

// Validate checks the field values on RoomUpdate with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RoomUpdate) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RoomUpdate with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RoomUpdateMultiError, or
// nil if none found.
func (m *RoomUpdate) ValidateAll() error {
	return m.validate(true)
}

func (m *RoomUpdate) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetRoom()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RoomUpdateValidationError{
					field:  "Room",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RoomUpdateValidationError{
					field:  "Room",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRoom()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RoomUpdateValidationError{
				field:  "Room",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return RoomUpdateMultiError(errors)
	}

	return nil
}

// RoomUpdateMultiError is an error wrapping multiple validation errors
// returned by RoomUpdate.ValidateAll() if the designated constraints aren't met.
type RoomUpdateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RoomUpdateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RoomUpdateMultiError) AllErrors() []error { return m }

// RoomUpdateValidationError is the validation error returned by
// RoomUpdate.Validate if the designated constraints aren't met.
type RoomUpdateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RoomUpdateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RoomUpdateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RoomUpdateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RoomUpdateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RoomUpdateValidationError) ErrorName() string { return "RoomUpdateValidationError" }

// Error satisfies the builtin error interface
func (e RoomUpdateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRoomUpdate.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RoomUpdateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RoomUpdateValidationError{}

// Validate checks the field values on ConnectionQualityInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ConnectionQualityInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ConnectionQualityInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ConnectionQualityInfoMultiError, or nil if none found.
func (m *ConnectionQualityInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *ConnectionQualityInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ParticipantSid

	// no validation rules for Quality

	// no validation rules for Score

	if len(errors) > 0 {
		return ConnectionQualityInfoMultiError(errors)
	}

	return nil
}

// ConnectionQualityInfoMultiError is an error wrapping multiple validation
// errors returned by ConnectionQualityInfo.ValidateAll() if the designated
// constraints aren't met.
type ConnectionQualityInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConnectionQualityInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConnectionQualityInfoMultiError) AllErrors() []error { return m }

// ConnectionQualityInfoValidationError is the validation error returned by
// ConnectionQualityInfo.Validate if the designated constraints aren't met.
type ConnectionQualityInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConnectionQualityInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConnectionQualityInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConnectionQualityInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConnectionQualityInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConnectionQualityInfoValidationError) ErrorName() string {
	return "ConnectionQualityInfoValidationError"
}

// Error satisfies the builtin error interface
func (e ConnectionQualityInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConnectionQualityInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConnectionQualityInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConnectionQualityInfoValidationError{}

// Validate checks the field values on ConnectionQualityUpdate with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ConnectionQualityUpdate) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ConnectionQualityUpdate with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ConnectionQualityUpdateMultiError, or nil if none found.
func (m *ConnectionQualityUpdate) ValidateAll() error {
	return m.validate(true)
}

func (m *ConnectionQualityUpdate) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetUpdates() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConnectionQualityUpdateValidationError{
						field:  fmt.Sprintf("Updates[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConnectionQualityUpdateValidationError{
						field:  fmt.Sprintf("Updates[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConnectionQualityUpdateValidationError{
					field:  fmt.Sprintf("Updates[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ConnectionQualityUpdateMultiError(errors)
	}

	return nil
}

// ConnectionQualityUpdateMultiError is an error wrapping multiple validation
// errors returned by ConnectionQualityUpdate.ValidateAll() if the designated
// constraints aren't met.
type ConnectionQualityUpdateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConnectionQualityUpdateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConnectionQualityUpdateMultiError) AllErrors() []error { return m }

// ConnectionQualityUpdateValidationError is the validation error returned by
// ConnectionQualityUpdate.Validate if the designated constraints aren't met.
type ConnectionQualityUpdateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConnectionQualityUpdateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConnectionQualityUpdateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConnectionQualityUpdateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConnectionQualityUpdateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConnectionQualityUpdateValidationError) ErrorName() string {
	return "ConnectionQualityUpdateValidationError"
}

// Error satisfies the builtin error interface
func (e ConnectionQualityUpdateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConnectionQualityUpdate.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConnectionQualityUpdateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConnectionQualityUpdateValidationError{}

// Validate checks the field values on StreamStateInfo with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *StreamStateInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StreamStateInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// StreamStateInfoMultiError, or nil if none found.
func (m *StreamStateInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *StreamStateInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ParticipantSid

	// no validation rules for TrackSid

	// no validation rules for State

	if len(errors) > 0 {
		return StreamStateInfoMultiError(errors)
	}

	return nil
}

// StreamStateInfoMultiError is an error wrapping multiple validation errors
// returned by StreamStateInfo.ValidateAll() if the designated constraints
// aren't met.
type StreamStateInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StreamStateInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StreamStateInfoMultiError) AllErrors() []error { return m }

// StreamStateInfoValidationError is the validation error returned by
// StreamStateInfo.Validate if the designated constraints aren't met.
type StreamStateInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StreamStateInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StreamStateInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StreamStateInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StreamStateInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StreamStateInfoValidationError) ErrorName() string { return "StreamStateInfoValidationError" }

// Error satisfies the builtin error interface
func (e StreamStateInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStreamStateInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StreamStateInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StreamStateInfoValidationError{}

// Validate checks the field values on StreamStateUpdate with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *StreamStateUpdate) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StreamStateUpdate with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// StreamStateUpdateMultiError, or nil if none found.
func (m *StreamStateUpdate) ValidateAll() error {
	return m.validate(true)
}

func (m *StreamStateUpdate) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetStreamStates() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StreamStateUpdateValidationError{
						field:  fmt.Sprintf("StreamStates[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StreamStateUpdateValidationError{
						field:  fmt.Sprintf("StreamStates[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StreamStateUpdateValidationError{
					field:  fmt.Sprintf("StreamStates[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return StreamStateUpdateMultiError(errors)
	}

	return nil
}

// StreamStateUpdateMultiError is an error wrapping multiple validation errors
// returned by StreamStateUpdate.ValidateAll() if the designated constraints
// aren't met.
type StreamStateUpdateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StreamStateUpdateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StreamStateUpdateMultiError) AllErrors() []error { return m }

// StreamStateUpdateValidationError is the validation error returned by
// StreamStateUpdate.Validate if the designated constraints aren't met.
type StreamStateUpdateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StreamStateUpdateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StreamStateUpdateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StreamStateUpdateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StreamStateUpdateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StreamStateUpdateValidationError) ErrorName() string {
	return "StreamStateUpdateValidationError"
}

// Error satisfies the builtin error interface
func (e StreamStateUpdateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStreamStateUpdate.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StreamStateUpdateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StreamStateUpdateValidationError{}

// Validate checks the field values on SubscribedQuality with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *SubscribedQuality) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SubscribedQuality with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SubscribedQualityMultiError, or nil if none found.
func (m *SubscribedQuality) ValidateAll() error {
	return m.validate(true)
}

func (m *SubscribedQuality) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Quality

	// no validation rules for Enabled

	if len(errors) > 0 {
		return SubscribedQualityMultiError(errors)
	}

	return nil
}

// SubscribedQualityMultiError is an error wrapping multiple validation errors
// returned by SubscribedQuality.ValidateAll() if the designated constraints
// aren't met.
type SubscribedQualityMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SubscribedQualityMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SubscribedQualityMultiError) AllErrors() []error { return m }

// SubscribedQualityValidationError is the validation error returned by
// SubscribedQuality.Validate if the designated constraints aren't met.
type SubscribedQualityValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SubscribedQualityValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SubscribedQualityValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SubscribedQualityValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SubscribedQualityValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SubscribedQualityValidationError) ErrorName() string {
	return "SubscribedQualityValidationError"
}

// Error satisfies the builtin error interface
func (e SubscribedQualityValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSubscribedQuality.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SubscribedQualityValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SubscribedQualityValidationError{}

// Validate checks the field values on SubscribedCodec with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *SubscribedCodec) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SubscribedCodec with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SubscribedCodecMultiError, or nil if none found.
func (m *SubscribedCodec) ValidateAll() error {
	return m.validate(true)
}

func (m *SubscribedCodec) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Codec

	for idx, item := range m.GetQualities() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SubscribedCodecValidationError{
						field:  fmt.Sprintf("Qualities[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SubscribedCodecValidationError{
						field:  fmt.Sprintf("Qualities[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SubscribedCodecValidationError{
					field:  fmt.Sprintf("Qualities[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return SubscribedCodecMultiError(errors)
	}

	return nil
}

// SubscribedCodecMultiError is an error wrapping multiple validation errors
// returned by SubscribedCodec.ValidateAll() if the designated constraints
// aren't met.
type SubscribedCodecMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SubscribedCodecMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SubscribedCodecMultiError) AllErrors() []error { return m }

// SubscribedCodecValidationError is the validation error returned by
// SubscribedCodec.Validate if the designated constraints aren't met.
type SubscribedCodecValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SubscribedCodecValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SubscribedCodecValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SubscribedCodecValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SubscribedCodecValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SubscribedCodecValidationError) ErrorName() string { return "SubscribedCodecValidationError" }

// Error satisfies the builtin error interface
func (e SubscribedCodecValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSubscribedCodec.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SubscribedCodecValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SubscribedCodecValidationError{}

// Validate checks the field values on SubscribedQualityUpdate with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SubscribedQualityUpdate) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SubscribedQualityUpdate with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SubscribedQualityUpdateMultiError, or nil if none found.
func (m *SubscribedQualityUpdate) ValidateAll() error {
	return m.validate(true)
}

func (m *SubscribedQualityUpdate) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TrackSid

	for idx, item := range m.GetSubscribedQualities() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SubscribedQualityUpdateValidationError{
						field:  fmt.Sprintf("SubscribedQualities[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SubscribedQualityUpdateValidationError{
						field:  fmt.Sprintf("SubscribedQualities[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SubscribedQualityUpdateValidationError{
					field:  fmt.Sprintf("SubscribedQualities[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetSubscribedCodecs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SubscribedQualityUpdateValidationError{
						field:  fmt.Sprintf("SubscribedCodecs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SubscribedQualityUpdateValidationError{
						field:  fmt.Sprintf("SubscribedCodecs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SubscribedQualityUpdateValidationError{
					field:  fmt.Sprintf("SubscribedCodecs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return SubscribedQualityUpdateMultiError(errors)
	}

	return nil
}

// SubscribedQualityUpdateMultiError is an error wrapping multiple validation
// errors returned by SubscribedQualityUpdate.ValidateAll() if the designated
// constraints aren't met.
type SubscribedQualityUpdateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SubscribedQualityUpdateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SubscribedQualityUpdateMultiError) AllErrors() []error { return m }

// SubscribedQualityUpdateValidationError is the validation error returned by
// SubscribedQualityUpdate.Validate if the designated constraints aren't met.
type SubscribedQualityUpdateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SubscribedQualityUpdateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SubscribedQualityUpdateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SubscribedQualityUpdateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SubscribedQualityUpdateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SubscribedQualityUpdateValidationError) ErrorName() string {
	return "SubscribedQualityUpdateValidationError"
}

// Error satisfies the builtin error interface
func (e SubscribedQualityUpdateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSubscribedQualityUpdate.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SubscribedQualityUpdateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SubscribedQualityUpdateValidationError{}

// Validate checks the field values on TrackPermission with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *TrackPermission) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TrackPermission with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TrackPermissionMultiError, or nil if none found.
func (m *TrackPermission) ValidateAll() error {
	return m.validate(true)
}

func (m *TrackPermission) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ParticipantSid

	// no validation rules for AllTracks

	// no validation rules for ParticipantIdentity

	if len(errors) > 0 {
		return TrackPermissionMultiError(errors)
	}

	return nil
}

// TrackPermissionMultiError is an error wrapping multiple validation errors
// returned by TrackPermission.ValidateAll() if the designated constraints
// aren't met.
type TrackPermissionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TrackPermissionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TrackPermissionMultiError) AllErrors() []error { return m }

// TrackPermissionValidationError is the validation error returned by
// TrackPermission.Validate if the designated constraints aren't met.
type TrackPermissionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TrackPermissionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TrackPermissionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TrackPermissionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TrackPermissionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TrackPermissionValidationError) ErrorName() string { return "TrackPermissionValidationError" }

// Error satisfies the builtin error interface
func (e TrackPermissionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTrackPermission.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TrackPermissionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TrackPermissionValidationError{}

// Validate checks the field values on SubscriptionPermission with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SubscriptionPermission) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SubscriptionPermission with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SubscriptionPermissionMultiError, or nil if none found.
func (m *SubscriptionPermission) ValidateAll() error {
	return m.validate(true)
}

func (m *SubscriptionPermission) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AllParticipants

	for idx, item := range m.GetTrackPermissions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SubscriptionPermissionValidationError{
						field:  fmt.Sprintf("TrackPermissions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SubscriptionPermissionValidationError{
						field:  fmt.Sprintf("TrackPermissions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SubscriptionPermissionValidationError{
					field:  fmt.Sprintf("TrackPermissions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return SubscriptionPermissionMultiError(errors)
	}

	return nil
}

// SubscriptionPermissionMultiError is an error wrapping multiple validation
// errors returned by SubscriptionPermission.ValidateAll() if the designated
// constraints aren't met.
type SubscriptionPermissionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SubscriptionPermissionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SubscriptionPermissionMultiError) AllErrors() []error { return m }

// SubscriptionPermissionValidationError is the validation error returned by
// SubscriptionPermission.Validate if the designated constraints aren't met.
type SubscriptionPermissionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SubscriptionPermissionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SubscriptionPermissionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SubscriptionPermissionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SubscriptionPermissionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SubscriptionPermissionValidationError) ErrorName() string {
	return "SubscriptionPermissionValidationError"
}

// Error satisfies the builtin error interface
func (e SubscriptionPermissionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSubscriptionPermission.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SubscriptionPermissionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SubscriptionPermissionValidationError{}

// Validate checks the field values on SubscriptionPermissionUpdate with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SubscriptionPermissionUpdate) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SubscriptionPermissionUpdate with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SubscriptionPermissionUpdateMultiError, or nil if none found.
func (m *SubscriptionPermissionUpdate) ValidateAll() error {
	return m.validate(true)
}

func (m *SubscriptionPermissionUpdate) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ParticipantSid

	// no validation rules for TrackSid

	// no validation rules for Allowed

	if len(errors) > 0 {
		return SubscriptionPermissionUpdateMultiError(errors)
	}

	return nil
}

// SubscriptionPermissionUpdateMultiError is an error wrapping multiple
// validation errors returned by SubscriptionPermissionUpdate.ValidateAll() if
// the designated constraints aren't met.
type SubscriptionPermissionUpdateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SubscriptionPermissionUpdateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SubscriptionPermissionUpdateMultiError) AllErrors() []error { return m }

// SubscriptionPermissionUpdateValidationError is the validation error returned
// by SubscriptionPermissionUpdate.Validate if the designated constraints
// aren't met.
type SubscriptionPermissionUpdateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SubscriptionPermissionUpdateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SubscriptionPermissionUpdateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SubscriptionPermissionUpdateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SubscriptionPermissionUpdateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SubscriptionPermissionUpdateValidationError) ErrorName() string {
	return "SubscriptionPermissionUpdateValidationError"
}

// Error satisfies the builtin error interface
func (e SubscriptionPermissionUpdateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSubscriptionPermissionUpdate.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SubscriptionPermissionUpdateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SubscriptionPermissionUpdateValidationError{}

// Validate checks the field values on SyncState with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SyncState) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SyncState with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SyncStateMultiError, or nil
// if none found.
func (m *SyncState) ValidateAll() error {
	return m.validate(true)
}

func (m *SyncState) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetAnswer()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SyncStateValidationError{
					field:  "Answer",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SyncStateValidationError{
					field:  "Answer",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAnswer()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SyncStateValidationError{
				field:  "Answer",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSubscription()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SyncStateValidationError{
					field:  "Subscription",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SyncStateValidationError{
					field:  "Subscription",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSubscription()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SyncStateValidationError{
				field:  "Subscription",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetPublishTracks() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SyncStateValidationError{
						field:  fmt.Sprintf("PublishTracks[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SyncStateValidationError{
						field:  fmt.Sprintf("PublishTracks[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SyncStateValidationError{
					field:  fmt.Sprintf("PublishTracks[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetDataChannels() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SyncStateValidationError{
						field:  fmt.Sprintf("DataChannels[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SyncStateValidationError{
						field:  fmt.Sprintf("DataChannels[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SyncStateValidationError{
					field:  fmt.Sprintf("DataChannels[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetOffer()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SyncStateValidationError{
					field:  "Offer",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SyncStateValidationError{
					field:  "Offer",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOffer()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SyncStateValidationError{
				field:  "Offer",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SyncStateMultiError(errors)
	}

	return nil
}

// SyncStateMultiError is an error wrapping multiple validation errors returned
// by SyncState.ValidateAll() if the designated constraints aren't met.
type SyncStateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SyncStateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SyncStateMultiError) AllErrors() []error { return m }

// SyncStateValidationError is the validation error returned by
// SyncState.Validate if the designated constraints aren't met.
type SyncStateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SyncStateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SyncStateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SyncStateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SyncStateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SyncStateValidationError) ErrorName() string { return "SyncStateValidationError" }

// Error satisfies the builtin error interface
func (e SyncStateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSyncState.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SyncStateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SyncStateValidationError{}

// Validate checks the field values on DataChannelInfo with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DataChannelInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DataChannelInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DataChannelInfoMultiError, or nil if none found.
func (m *DataChannelInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *DataChannelInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Label

	// no validation rules for Id

	// no validation rules for Target

	if len(errors) > 0 {
		return DataChannelInfoMultiError(errors)
	}

	return nil
}

// DataChannelInfoMultiError is an error wrapping multiple validation errors
// returned by DataChannelInfo.ValidateAll() if the designated constraints
// aren't met.
type DataChannelInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DataChannelInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DataChannelInfoMultiError) AllErrors() []error { return m }

// DataChannelInfoValidationError is the validation error returned by
// DataChannelInfo.Validate if the designated constraints aren't met.
type DataChannelInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DataChannelInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DataChannelInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DataChannelInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DataChannelInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DataChannelInfoValidationError) ErrorName() string { return "DataChannelInfoValidationError" }

// Error satisfies the builtin error interface
func (e DataChannelInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDataChannelInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DataChannelInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DataChannelInfoValidationError{}

// Validate checks the field values on SimulateScenario with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *SimulateScenario) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SimulateScenario with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SimulateScenarioMultiError, or nil if none found.
func (m *SimulateScenario) ValidateAll() error {
	return m.validate(true)
}

func (m *SimulateScenario) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Scenario.(type) {
	case *SimulateScenario_SpeakerUpdate:
		if v == nil {
			err := SimulateScenarioValidationError{
				field:  "Scenario",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for SpeakerUpdate
	case *SimulateScenario_NodeFailure:
		if v == nil {
			err := SimulateScenarioValidationError{
				field:  "Scenario",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for NodeFailure
	case *SimulateScenario_Migration:
		if v == nil {
			err := SimulateScenarioValidationError{
				field:  "Scenario",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for Migration
	case *SimulateScenario_ServerLeave:
		if v == nil {
			err := SimulateScenarioValidationError{
				field:  "Scenario",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for ServerLeave
	case *SimulateScenario_SwitchCandidateProtocol:
		if v == nil {
			err := SimulateScenarioValidationError{
				field:  "Scenario",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for SwitchCandidateProtocol
	case *SimulateScenario_SubscriberBandwidth:
		if v == nil {
			err := SimulateScenarioValidationError{
				field:  "Scenario",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for SubscriberBandwidth
	case *SimulateScenario_DisconnectSignalOnResume:
		if v == nil {
			err := SimulateScenarioValidationError{
				field:  "Scenario",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for DisconnectSignalOnResume
	case *SimulateScenario_DisconnectSignalOnResumeNoMessages:
		if v == nil {
			err := SimulateScenarioValidationError{
				field:  "Scenario",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for DisconnectSignalOnResumeNoMessages
	case *SimulateScenario_LeaveRequestFullReconnect:
		if v == nil {
			err := SimulateScenarioValidationError{
				field:  "Scenario",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for LeaveRequestFullReconnect
	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return SimulateScenarioMultiError(errors)
	}

	return nil
}

// SimulateScenarioMultiError is an error wrapping multiple validation errors
// returned by SimulateScenario.ValidateAll() if the designated constraints
// aren't met.
type SimulateScenarioMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SimulateScenarioMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SimulateScenarioMultiError) AllErrors() []error { return m }

// SimulateScenarioValidationError is the validation error returned by
// SimulateScenario.Validate if the designated constraints aren't met.
type SimulateScenarioValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SimulateScenarioValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SimulateScenarioValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SimulateScenarioValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SimulateScenarioValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SimulateScenarioValidationError) ErrorName() string { return "SimulateScenarioValidationError" }

// Error satisfies the builtin error interface
func (e SimulateScenarioValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSimulateScenario.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SimulateScenarioValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SimulateScenarioValidationError{}

// Validate checks the field values on Ping with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Ping) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Ping with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in PingMultiError, or nil if none found.
func (m *Ping) ValidateAll() error {
	return m.validate(true)
}

func (m *Ping) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Timestamp

	// no validation rules for Rtt

	if len(errors) > 0 {
		return PingMultiError(errors)
	}

	return nil
}

// PingMultiError is an error wrapping multiple validation errors returned by
// Ping.ValidateAll() if the designated constraints aren't met.
type PingMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PingMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PingMultiError) AllErrors() []error { return m }

// PingValidationError is the validation error returned by Ping.Validate if the
// designated constraints aren't met.
type PingValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PingValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PingValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PingValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PingValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PingValidationError) ErrorName() string { return "PingValidationError" }

// Error satisfies the builtin error interface
func (e PingValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPing.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PingValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PingValidationError{}

// Validate checks the field values on Pong with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Pong) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Pong with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in PongMultiError, or nil if none found.
func (m *Pong) ValidateAll() error {
	return m.validate(true)
}

func (m *Pong) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for LastPingTimestamp

	// no validation rules for Timestamp

	if len(errors) > 0 {
		return PongMultiError(errors)
	}

	return nil
}

// PongMultiError is an error wrapping multiple validation errors returned by
// Pong.ValidateAll() if the designated constraints aren't met.
type PongMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PongMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PongMultiError) AllErrors() []error { return m }

// PongValidationError is the validation error returned by Pong.Validate if the
// designated constraints aren't met.
type PongValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PongValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PongValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PongValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PongValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PongValidationError) ErrorName() string { return "PongValidationError" }

// Error satisfies the builtin error interface
func (e PongValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPong.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PongValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PongValidationError{}

// Validate checks the field values on RegionSettings with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RegionSettings) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RegionSettings with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RegionSettingsMultiError,
// or nil if none found.
func (m *RegionSettings) ValidateAll() error {
	return m.validate(true)
}

func (m *RegionSettings) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetRegions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RegionSettingsValidationError{
						field:  fmt.Sprintf("Regions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RegionSettingsValidationError{
						field:  fmt.Sprintf("Regions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RegionSettingsValidationError{
					field:  fmt.Sprintf("Regions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return RegionSettingsMultiError(errors)
	}

	return nil
}

// RegionSettingsMultiError is an error wrapping multiple validation errors
// returned by RegionSettings.ValidateAll() if the designated constraints
// aren't met.
type RegionSettingsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RegionSettingsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RegionSettingsMultiError) AllErrors() []error { return m }

// RegionSettingsValidationError is the validation error returned by
// RegionSettings.Validate if the designated constraints aren't met.
type RegionSettingsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RegionSettingsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RegionSettingsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RegionSettingsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RegionSettingsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RegionSettingsValidationError) ErrorName() string { return "RegionSettingsValidationError" }

// Error satisfies the builtin error interface
func (e RegionSettingsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRegionSettings.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RegionSettingsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RegionSettingsValidationError{}

// Validate checks the field values on RegionInfo with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RegionInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RegionInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RegionInfoMultiError, or
// nil if none found.
func (m *RegionInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *RegionInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Region

	// no validation rules for Url

	// no validation rules for Distance

	if len(errors) > 0 {
		return RegionInfoMultiError(errors)
	}

	return nil
}

// RegionInfoMultiError is an error wrapping multiple validation errors
// returned by RegionInfo.ValidateAll() if the designated constraints aren't met.
type RegionInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RegionInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RegionInfoMultiError) AllErrors() []error { return m }

// RegionInfoValidationError is the validation error returned by
// RegionInfo.Validate if the designated constraints aren't met.
type RegionInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RegionInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RegionInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RegionInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RegionInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RegionInfoValidationError) ErrorName() string { return "RegionInfoValidationError" }

// Error satisfies the builtin error interface
func (e RegionInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRegionInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RegionInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RegionInfoValidationError{}

// Validate checks the field values on SubscriptionResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SubscriptionResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SubscriptionResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SubscriptionResponseMultiError, or nil if none found.
func (m *SubscriptionResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *SubscriptionResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TrackSid

	// no validation rules for Err

	if len(errors) > 0 {
		return SubscriptionResponseMultiError(errors)
	}

	return nil
}

// SubscriptionResponseMultiError is an error wrapping multiple validation
// errors returned by SubscriptionResponse.ValidateAll() if the designated
// constraints aren't met.
type SubscriptionResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SubscriptionResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SubscriptionResponseMultiError) AllErrors() []error { return m }

// SubscriptionResponseValidationError is the validation error returned by
// SubscriptionResponse.Validate if the designated constraints aren't met.
type SubscriptionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SubscriptionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SubscriptionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SubscriptionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SubscriptionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SubscriptionResponseValidationError) ErrorName() string {
	return "SubscriptionResponseValidationError"
}

// Error satisfies the builtin error interface
func (e SubscriptionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSubscriptionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SubscriptionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SubscriptionResponseValidationError{}

// Validate checks the field values on RequestResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *RequestResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RequestResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RequestResponseMultiError, or nil if none found.
func (m *RequestResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *RequestResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for RequestId

	// no validation rules for Reason

	// no validation rules for Message

	if len(errors) > 0 {
		return RequestResponseMultiError(errors)
	}

	return nil
}

// RequestResponseMultiError is an error wrapping multiple validation errors
// returned by RequestResponse.ValidateAll() if the designated constraints
// aren't met.
type RequestResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RequestResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RequestResponseMultiError) AllErrors() []error { return m }

// RequestResponseValidationError is the validation error returned by
// RequestResponse.Validate if the designated constraints aren't met.
type RequestResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RequestResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RequestResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RequestResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RequestResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RequestResponseValidationError) ErrorName() string { return "RequestResponseValidationError" }

// Error satisfies the builtin error interface
func (e RequestResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRequestResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RequestResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RequestResponseValidationError{}

// Validate checks the field values on TrackSubscribed with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *TrackSubscribed) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TrackSubscribed with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TrackSubscribedMultiError, or nil if none found.
func (m *TrackSubscribed) ValidateAll() error {
	return m.validate(true)
}

func (m *TrackSubscribed) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TrackSid

	if len(errors) > 0 {
		return TrackSubscribedMultiError(errors)
	}

	return nil
}

// TrackSubscribedMultiError is an error wrapping multiple validation errors
// returned by TrackSubscribed.ValidateAll() if the designated constraints
// aren't met.
type TrackSubscribedMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TrackSubscribedMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TrackSubscribedMultiError) AllErrors() []error { return m }

// TrackSubscribedValidationError is the validation error returned by
// TrackSubscribed.Validate if the designated constraints aren't met.
type TrackSubscribedValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TrackSubscribedValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TrackSubscribedValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TrackSubscribedValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TrackSubscribedValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TrackSubscribedValidationError) ErrorName() string { return "TrackSubscribedValidationError" }

// Error satisfies the builtin error interface
func (e TrackSubscribedValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTrackSubscribed.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TrackSubscribedValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TrackSubscribedValidationError{}
