// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: livekit_egress.proto

package livekit

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on RoomCompositeEgressRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RoomCompositeEgressRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RoomCompositeEgressRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RoomCompositeEgressRequestMultiError, or nil if none found.
func (m *RoomCompositeEgressRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *RoomCompositeEgressRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for RoomName

	// no validation rules for Layout

	// no validation rules for AudioOnly

	// no validation rules for VideoOnly

	// no validation rules for CustomBaseUrl

	for idx, item := range m.GetFileOutputs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RoomCompositeEgressRequestValidationError{
						field:  fmt.Sprintf("FileOutputs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RoomCompositeEgressRequestValidationError{
						field:  fmt.Sprintf("FileOutputs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RoomCompositeEgressRequestValidationError{
					field:  fmt.Sprintf("FileOutputs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetStreamOutputs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RoomCompositeEgressRequestValidationError{
						field:  fmt.Sprintf("StreamOutputs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RoomCompositeEgressRequestValidationError{
						field:  fmt.Sprintf("StreamOutputs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RoomCompositeEgressRequestValidationError{
					field:  fmt.Sprintf("StreamOutputs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetSegmentOutputs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RoomCompositeEgressRequestValidationError{
						field:  fmt.Sprintf("SegmentOutputs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RoomCompositeEgressRequestValidationError{
						field:  fmt.Sprintf("SegmentOutputs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RoomCompositeEgressRequestValidationError{
					field:  fmt.Sprintf("SegmentOutputs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetImageOutputs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RoomCompositeEgressRequestValidationError{
						field:  fmt.Sprintf("ImageOutputs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RoomCompositeEgressRequestValidationError{
						field:  fmt.Sprintf("ImageOutputs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RoomCompositeEgressRequestValidationError{
					field:  fmt.Sprintf("ImageOutputs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	switch v := m.Output.(type) {
	case *RoomCompositeEgressRequest_File:
		if v == nil {
			err := RoomCompositeEgressRequestValidationError{
				field:  "Output",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetFile()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RoomCompositeEgressRequestValidationError{
						field:  "File",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RoomCompositeEgressRequestValidationError{
						field:  "File",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetFile()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RoomCompositeEgressRequestValidationError{
					field:  "File",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *RoomCompositeEgressRequest_Stream:
		if v == nil {
			err := RoomCompositeEgressRequestValidationError{
				field:  "Output",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetStream()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RoomCompositeEgressRequestValidationError{
						field:  "Stream",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RoomCompositeEgressRequestValidationError{
						field:  "Stream",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetStream()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RoomCompositeEgressRequestValidationError{
					field:  "Stream",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *RoomCompositeEgressRequest_Segments:
		if v == nil {
			err := RoomCompositeEgressRequestValidationError{
				field:  "Output",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetSegments()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RoomCompositeEgressRequestValidationError{
						field:  "Segments",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RoomCompositeEgressRequestValidationError{
						field:  "Segments",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSegments()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RoomCompositeEgressRequestValidationError{
					field:  "Segments",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}
	switch v := m.Options.(type) {
	case *RoomCompositeEgressRequest_Preset:
		if v == nil {
			err := RoomCompositeEgressRequestValidationError{
				field:  "Options",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for Preset
	case *RoomCompositeEgressRequest_Advanced:
		if v == nil {
			err := RoomCompositeEgressRequestValidationError{
				field:  "Options",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetAdvanced()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RoomCompositeEgressRequestValidationError{
						field:  "Advanced",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RoomCompositeEgressRequestValidationError{
						field:  "Advanced",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAdvanced()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RoomCompositeEgressRequestValidationError{
					field:  "Advanced",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return RoomCompositeEgressRequestMultiError(errors)
	}

	return nil
}

// RoomCompositeEgressRequestMultiError is an error wrapping multiple
// validation errors returned by RoomCompositeEgressRequest.ValidateAll() if
// the designated constraints aren't met.
type RoomCompositeEgressRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RoomCompositeEgressRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RoomCompositeEgressRequestMultiError) AllErrors() []error { return m }

// RoomCompositeEgressRequestValidationError is the validation error returned
// by RoomCompositeEgressRequest.Validate if the designated constraints aren't met.
type RoomCompositeEgressRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RoomCompositeEgressRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RoomCompositeEgressRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RoomCompositeEgressRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RoomCompositeEgressRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RoomCompositeEgressRequestValidationError) ErrorName() string {
	return "RoomCompositeEgressRequestValidationError"
}

// Error satisfies the builtin error interface
func (e RoomCompositeEgressRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRoomCompositeEgressRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RoomCompositeEgressRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RoomCompositeEgressRequestValidationError{}

// Validate checks the field values on WebEgressRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *WebEgressRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WebEgressRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// WebEgressRequestMultiError, or nil if none found.
func (m *WebEgressRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *WebEgressRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Url

	// no validation rules for AudioOnly

	// no validation rules for VideoOnly

	// no validation rules for AwaitStartSignal

	for idx, item := range m.GetFileOutputs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, WebEgressRequestValidationError{
						field:  fmt.Sprintf("FileOutputs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, WebEgressRequestValidationError{
						field:  fmt.Sprintf("FileOutputs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return WebEgressRequestValidationError{
					field:  fmt.Sprintf("FileOutputs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetStreamOutputs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, WebEgressRequestValidationError{
						field:  fmt.Sprintf("StreamOutputs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, WebEgressRequestValidationError{
						field:  fmt.Sprintf("StreamOutputs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return WebEgressRequestValidationError{
					field:  fmt.Sprintf("StreamOutputs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetSegmentOutputs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, WebEgressRequestValidationError{
						field:  fmt.Sprintf("SegmentOutputs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, WebEgressRequestValidationError{
						field:  fmt.Sprintf("SegmentOutputs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return WebEgressRequestValidationError{
					field:  fmt.Sprintf("SegmentOutputs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetImageOutputs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, WebEgressRequestValidationError{
						field:  fmt.Sprintf("ImageOutputs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, WebEgressRequestValidationError{
						field:  fmt.Sprintf("ImageOutputs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return WebEgressRequestValidationError{
					field:  fmt.Sprintf("ImageOutputs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	switch v := m.Output.(type) {
	case *WebEgressRequest_File:
		if v == nil {
			err := WebEgressRequestValidationError{
				field:  "Output",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetFile()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, WebEgressRequestValidationError{
						field:  "File",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, WebEgressRequestValidationError{
						field:  "File",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetFile()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return WebEgressRequestValidationError{
					field:  "File",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *WebEgressRequest_Stream:
		if v == nil {
			err := WebEgressRequestValidationError{
				field:  "Output",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetStream()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, WebEgressRequestValidationError{
						field:  "Stream",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, WebEgressRequestValidationError{
						field:  "Stream",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetStream()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return WebEgressRequestValidationError{
					field:  "Stream",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *WebEgressRequest_Segments:
		if v == nil {
			err := WebEgressRequestValidationError{
				field:  "Output",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetSegments()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, WebEgressRequestValidationError{
						field:  "Segments",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, WebEgressRequestValidationError{
						field:  "Segments",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSegments()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return WebEgressRequestValidationError{
					field:  "Segments",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}
	switch v := m.Options.(type) {
	case *WebEgressRequest_Preset:
		if v == nil {
			err := WebEgressRequestValidationError{
				field:  "Options",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for Preset
	case *WebEgressRequest_Advanced:
		if v == nil {
			err := WebEgressRequestValidationError{
				field:  "Options",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetAdvanced()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, WebEgressRequestValidationError{
						field:  "Advanced",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, WebEgressRequestValidationError{
						field:  "Advanced",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAdvanced()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return WebEgressRequestValidationError{
					field:  "Advanced",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return WebEgressRequestMultiError(errors)
	}

	return nil
}

// WebEgressRequestMultiError is an error wrapping multiple validation errors
// returned by WebEgressRequest.ValidateAll() if the designated constraints
// aren't met.
type WebEgressRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WebEgressRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WebEgressRequestMultiError) AllErrors() []error { return m }

// WebEgressRequestValidationError is the validation error returned by
// WebEgressRequest.Validate if the designated constraints aren't met.
type WebEgressRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WebEgressRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WebEgressRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WebEgressRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WebEgressRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WebEgressRequestValidationError) ErrorName() string { return "WebEgressRequestValidationError" }

// Error satisfies the builtin error interface
func (e WebEgressRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWebEgressRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WebEgressRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WebEgressRequestValidationError{}

// Validate checks the field values on ParticipantEgressRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ParticipantEgressRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ParticipantEgressRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ParticipantEgressRequestMultiError, or nil if none found.
func (m *ParticipantEgressRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ParticipantEgressRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for RoomName

	// no validation rules for Identity

	// no validation rules for ScreenShare

	for idx, item := range m.GetFileOutputs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ParticipantEgressRequestValidationError{
						field:  fmt.Sprintf("FileOutputs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ParticipantEgressRequestValidationError{
						field:  fmt.Sprintf("FileOutputs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ParticipantEgressRequestValidationError{
					field:  fmt.Sprintf("FileOutputs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetStreamOutputs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ParticipantEgressRequestValidationError{
						field:  fmt.Sprintf("StreamOutputs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ParticipantEgressRequestValidationError{
						field:  fmt.Sprintf("StreamOutputs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ParticipantEgressRequestValidationError{
					field:  fmt.Sprintf("StreamOutputs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetSegmentOutputs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ParticipantEgressRequestValidationError{
						field:  fmt.Sprintf("SegmentOutputs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ParticipantEgressRequestValidationError{
						field:  fmt.Sprintf("SegmentOutputs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ParticipantEgressRequestValidationError{
					field:  fmt.Sprintf("SegmentOutputs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetImageOutputs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ParticipantEgressRequestValidationError{
						field:  fmt.Sprintf("ImageOutputs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ParticipantEgressRequestValidationError{
						field:  fmt.Sprintf("ImageOutputs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ParticipantEgressRequestValidationError{
					field:  fmt.Sprintf("ImageOutputs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	switch v := m.Options.(type) {
	case *ParticipantEgressRequest_Preset:
		if v == nil {
			err := ParticipantEgressRequestValidationError{
				field:  "Options",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for Preset
	case *ParticipantEgressRequest_Advanced:
		if v == nil {
			err := ParticipantEgressRequestValidationError{
				field:  "Options",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetAdvanced()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ParticipantEgressRequestValidationError{
						field:  "Advanced",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ParticipantEgressRequestValidationError{
						field:  "Advanced",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAdvanced()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ParticipantEgressRequestValidationError{
					field:  "Advanced",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return ParticipantEgressRequestMultiError(errors)
	}

	return nil
}

// ParticipantEgressRequestMultiError is an error wrapping multiple validation
// errors returned by ParticipantEgressRequest.ValidateAll() if the designated
// constraints aren't met.
type ParticipantEgressRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ParticipantEgressRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ParticipantEgressRequestMultiError) AllErrors() []error { return m }

// ParticipantEgressRequestValidationError is the validation error returned by
// ParticipantEgressRequest.Validate if the designated constraints aren't met.
type ParticipantEgressRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ParticipantEgressRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ParticipantEgressRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ParticipantEgressRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ParticipantEgressRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ParticipantEgressRequestValidationError) ErrorName() string {
	return "ParticipantEgressRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ParticipantEgressRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sParticipantEgressRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ParticipantEgressRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ParticipantEgressRequestValidationError{}

// Validate checks the field values on TrackCompositeEgressRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TrackCompositeEgressRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TrackCompositeEgressRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TrackCompositeEgressRequestMultiError, or nil if none found.
func (m *TrackCompositeEgressRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *TrackCompositeEgressRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for RoomName

	// no validation rules for AudioTrackId

	// no validation rules for VideoTrackId

	for idx, item := range m.GetFileOutputs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TrackCompositeEgressRequestValidationError{
						field:  fmt.Sprintf("FileOutputs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TrackCompositeEgressRequestValidationError{
						field:  fmt.Sprintf("FileOutputs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TrackCompositeEgressRequestValidationError{
					field:  fmt.Sprintf("FileOutputs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetStreamOutputs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TrackCompositeEgressRequestValidationError{
						field:  fmt.Sprintf("StreamOutputs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TrackCompositeEgressRequestValidationError{
						field:  fmt.Sprintf("StreamOutputs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TrackCompositeEgressRequestValidationError{
					field:  fmt.Sprintf("StreamOutputs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetSegmentOutputs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TrackCompositeEgressRequestValidationError{
						field:  fmt.Sprintf("SegmentOutputs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TrackCompositeEgressRequestValidationError{
						field:  fmt.Sprintf("SegmentOutputs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TrackCompositeEgressRequestValidationError{
					field:  fmt.Sprintf("SegmentOutputs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetImageOutputs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TrackCompositeEgressRequestValidationError{
						field:  fmt.Sprintf("ImageOutputs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TrackCompositeEgressRequestValidationError{
						field:  fmt.Sprintf("ImageOutputs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TrackCompositeEgressRequestValidationError{
					field:  fmt.Sprintf("ImageOutputs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	switch v := m.Output.(type) {
	case *TrackCompositeEgressRequest_File:
		if v == nil {
			err := TrackCompositeEgressRequestValidationError{
				field:  "Output",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetFile()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TrackCompositeEgressRequestValidationError{
						field:  "File",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TrackCompositeEgressRequestValidationError{
						field:  "File",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetFile()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TrackCompositeEgressRequestValidationError{
					field:  "File",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *TrackCompositeEgressRequest_Stream:
		if v == nil {
			err := TrackCompositeEgressRequestValidationError{
				field:  "Output",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetStream()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TrackCompositeEgressRequestValidationError{
						field:  "Stream",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TrackCompositeEgressRequestValidationError{
						field:  "Stream",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetStream()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TrackCompositeEgressRequestValidationError{
					field:  "Stream",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *TrackCompositeEgressRequest_Segments:
		if v == nil {
			err := TrackCompositeEgressRequestValidationError{
				field:  "Output",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetSegments()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TrackCompositeEgressRequestValidationError{
						field:  "Segments",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TrackCompositeEgressRequestValidationError{
						field:  "Segments",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSegments()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TrackCompositeEgressRequestValidationError{
					field:  "Segments",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}
	switch v := m.Options.(type) {
	case *TrackCompositeEgressRequest_Preset:
		if v == nil {
			err := TrackCompositeEgressRequestValidationError{
				field:  "Options",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for Preset
	case *TrackCompositeEgressRequest_Advanced:
		if v == nil {
			err := TrackCompositeEgressRequestValidationError{
				field:  "Options",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetAdvanced()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TrackCompositeEgressRequestValidationError{
						field:  "Advanced",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TrackCompositeEgressRequestValidationError{
						field:  "Advanced",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAdvanced()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TrackCompositeEgressRequestValidationError{
					field:  "Advanced",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return TrackCompositeEgressRequestMultiError(errors)
	}

	return nil
}

// TrackCompositeEgressRequestMultiError is an error wrapping multiple
// validation errors returned by TrackCompositeEgressRequest.ValidateAll() if
// the designated constraints aren't met.
type TrackCompositeEgressRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TrackCompositeEgressRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TrackCompositeEgressRequestMultiError) AllErrors() []error { return m }

// TrackCompositeEgressRequestValidationError is the validation error returned
// by TrackCompositeEgressRequest.Validate if the designated constraints
// aren't met.
type TrackCompositeEgressRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TrackCompositeEgressRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TrackCompositeEgressRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TrackCompositeEgressRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TrackCompositeEgressRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TrackCompositeEgressRequestValidationError) ErrorName() string {
	return "TrackCompositeEgressRequestValidationError"
}

// Error satisfies the builtin error interface
func (e TrackCompositeEgressRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTrackCompositeEgressRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TrackCompositeEgressRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TrackCompositeEgressRequestValidationError{}

// Validate checks the field values on TrackEgressRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TrackEgressRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TrackEgressRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TrackEgressRequestMultiError, or nil if none found.
func (m *TrackEgressRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *TrackEgressRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for RoomName

	// no validation rules for TrackId

	switch v := m.Output.(type) {
	case *TrackEgressRequest_File:
		if v == nil {
			err := TrackEgressRequestValidationError{
				field:  "Output",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetFile()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TrackEgressRequestValidationError{
						field:  "File",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TrackEgressRequestValidationError{
						field:  "File",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetFile()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TrackEgressRequestValidationError{
					field:  "File",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *TrackEgressRequest_WebsocketUrl:
		if v == nil {
			err := TrackEgressRequestValidationError{
				field:  "Output",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for WebsocketUrl
	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return TrackEgressRequestMultiError(errors)
	}

	return nil
}

// TrackEgressRequestMultiError is an error wrapping multiple validation errors
// returned by TrackEgressRequest.ValidateAll() if the designated constraints
// aren't met.
type TrackEgressRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TrackEgressRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TrackEgressRequestMultiError) AllErrors() []error { return m }

// TrackEgressRequestValidationError is the validation error returned by
// TrackEgressRequest.Validate if the designated constraints aren't met.
type TrackEgressRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TrackEgressRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TrackEgressRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TrackEgressRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TrackEgressRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TrackEgressRequestValidationError) ErrorName() string {
	return "TrackEgressRequestValidationError"
}

// Error satisfies the builtin error interface
func (e TrackEgressRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTrackEgressRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TrackEgressRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TrackEgressRequestValidationError{}

// Validate checks the field values on EncodedFileOutput with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *EncodedFileOutput) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EncodedFileOutput with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// EncodedFileOutputMultiError, or nil if none found.
func (m *EncodedFileOutput) ValidateAll() error {
	return m.validate(true)
}

func (m *EncodedFileOutput) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for FileType

	// no validation rules for Filepath

	// no validation rules for DisableManifest

	switch v := m.Output.(type) {
	case *EncodedFileOutput_S3:
		if v == nil {
			err := EncodedFileOutputValidationError{
				field:  "Output",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetS3()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EncodedFileOutputValidationError{
						field:  "S3",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EncodedFileOutputValidationError{
						field:  "S3",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetS3()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EncodedFileOutputValidationError{
					field:  "S3",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *EncodedFileOutput_Gcp:
		if v == nil {
			err := EncodedFileOutputValidationError{
				field:  "Output",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetGcp()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EncodedFileOutputValidationError{
						field:  "Gcp",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EncodedFileOutputValidationError{
						field:  "Gcp",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetGcp()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EncodedFileOutputValidationError{
					field:  "Gcp",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *EncodedFileOutput_Azure:
		if v == nil {
			err := EncodedFileOutputValidationError{
				field:  "Output",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetAzure()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EncodedFileOutputValidationError{
						field:  "Azure",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EncodedFileOutputValidationError{
						field:  "Azure",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAzure()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EncodedFileOutputValidationError{
					field:  "Azure",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *EncodedFileOutput_AliOSS:
		if v == nil {
			err := EncodedFileOutputValidationError{
				field:  "Output",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetAliOSS()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EncodedFileOutputValidationError{
						field:  "AliOSS",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EncodedFileOutputValidationError{
						field:  "AliOSS",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAliOSS()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EncodedFileOutputValidationError{
					field:  "AliOSS",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return EncodedFileOutputMultiError(errors)
	}

	return nil
}

// EncodedFileOutputMultiError is an error wrapping multiple validation errors
// returned by EncodedFileOutput.ValidateAll() if the designated constraints
// aren't met.
type EncodedFileOutputMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EncodedFileOutputMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EncodedFileOutputMultiError) AllErrors() []error { return m }

// EncodedFileOutputValidationError is the validation error returned by
// EncodedFileOutput.Validate if the designated constraints aren't met.
type EncodedFileOutputValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EncodedFileOutputValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EncodedFileOutputValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EncodedFileOutputValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EncodedFileOutputValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EncodedFileOutputValidationError) ErrorName() string {
	return "EncodedFileOutputValidationError"
}

// Error satisfies the builtin error interface
func (e EncodedFileOutputValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEncodedFileOutput.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EncodedFileOutputValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EncodedFileOutputValidationError{}

// Validate checks the field values on SegmentedFileOutput with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SegmentedFileOutput) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SegmentedFileOutput with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SegmentedFileOutputMultiError, or nil if none found.
func (m *SegmentedFileOutput) ValidateAll() error {
	return m.validate(true)
}

func (m *SegmentedFileOutput) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Protocol

	// no validation rules for FilenamePrefix

	// no validation rules for PlaylistName

	// no validation rules for LivePlaylistName

	// no validation rules for SegmentDuration

	// no validation rules for FilenameSuffix

	// no validation rules for DisableManifest

	switch v := m.Output.(type) {
	case *SegmentedFileOutput_S3:
		if v == nil {
			err := SegmentedFileOutputValidationError{
				field:  "Output",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetS3()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SegmentedFileOutputValidationError{
						field:  "S3",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SegmentedFileOutputValidationError{
						field:  "S3",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetS3()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SegmentedFileOutputValidationError{
					field:  "S3",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *SegmentedFileOutput_Gcp:
		if v == nil {
			err := SegmentedFileOutputValidationError{
				field:  "Output",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetGcp()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SegmentedFileOutputValidationError{
						field:  "Gcp",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SegmentedFileOutputValidationError{
						field:  "Gcp",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetGcp()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SegmentedFileOutputValidationError{
					field:  "Gcp",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *SegmentedFileOutput_Azure:
		if v == nil {
			err := SegmentedFileOutputValidationError{
				field:  "Output",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetAzure()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SegmentedFileOutputValidationError{
						field:  "Azure",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SegmentedFileOutputValidationError{
						field:  "Azure",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAzure()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SegmentedFileOutputValidationError{
					field:  "Azure",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *SegmentedFileOutput_AliOSS:
		if v == nil {
			err := SegmentedFileOutputValidationError{
				field:  "Output",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetAliOSS()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SegmentedFileOutputValidationError{
						field:  "AliOSS",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SegmentedFileOutputValidationError{
						field:  "AliOSS",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAliOSS()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SegmentedFileOutputValidationError{
					field:  "AliOSS",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return SegmentedFileOutputMultiError(errors)
	}

	return nil
}

// SegmentedFileOutputMultiError is an error wrapping multiple validation
// errors returned by SegmentedFileOutput.ValidateAll() if the designated
// constraints aren't met.
type SegmentedFileOutputMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SegmentedFileOutputMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SegmentedFileOutputMultiError) AllErrors() []error { return m }

// SegmentedFileOutputValidationError is the validation error returned by
// SegmentedFileOutput.Validate if the designated constraints aren't met.
type SegmentedFileOutputValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SegmentedFileOutputValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SegmentedFileOutputValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SegmentedFileOutputValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SegmentedFileOutputValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SegmentedFileOutputValidationError) ErrorName() string {
	return "SegmentedFileOutputValidationError"
}

// Error satisfies the builtin error interface
func (e SegmentedFileOutputValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSegmentedFileOutput.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SegmentedFileOutputValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SegmentedFileOutputValidationError{}

// Validate checks the field values on DirectFileOutput with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DirectFileOutput) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DirectFileOutput with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DirectFileOutputMultiError, or nil if none found.
func (m *DirectFileOutput) ValidateAll() error {
	return m.validate(true)
}

func (m *DirectFileOutput) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Filepath

	// no validation rules for DisableManifest

	switch v := m.Output.(type) {
	case *DirectFileOutput_S3:
		if v == nil {
			err := DirectFileOutputValidationError{
				field:  "Output",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetS3()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DirectFileOutputValidationError{
						field:  "S3",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DirectFileOutputValidationError{
						field:  "S3",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetS3()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DirectFileOutputValidationError{
					field:  "S3",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *DirectFileOutput_Gcp:
		if v == nil {
			err := DirectFileOutputValidationError{
				field:  "Output",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetGcp()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DirectFileOutputValidationError{
						field:  "Gcp",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DirectFileOutputValidationError{
						field:  "Gcp",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetGcp()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DirectFileOutputValidationError{
					field:  "Gcp",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *DirectFileOutput_Azure:
		if v == nil {
			err := DirectFileOutputValidationError{
				field:  "Output",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetAzure()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DirectFileOutputValidationError{
						field:  "Azure",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DirectFileOutputValidationError{
						field:  "Azure",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAzure()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DirectFileOutputValidationError{
					field:  "Azure",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *DirectFileOutput_AliOSS:
		if v == nil {
			err := DirectFileOutputValidationError{
				field:  "Output",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetAliOSS()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DirectFileOutputValidationError{
						field:  "AliOSS",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DirectFileOutputValidationError{
						field:  "AliOSS",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAliOSS()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DirectFileOutputValidationError{
					field:  "AliOSS",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return DirectFileOutputMultiError(errors)
	}

	return nil
}

// DirectFileOutputMultiError is an error wrapping multiple validation errors
// returned by DirectFileOutput.ValidateAll() if the designated constraints
// aren't met.
type DirectFileOutputMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DirectFileOutputMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DirectFileOutputMultiError) AllErrors() []error { return m }

// DirectFileOutputValidationError is the validation error returned by
// DirectFileOutput.Validate if the designated constraints aren't met.
type DirectFileOutputValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DirectFileOutputValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DirectFileOutputValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DirectFileOutputValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DirectFileOutputValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DirectFileOutputValidationError) ErrorName() string { return "DirectFileOutputValidationError" }

// Error satisfies the builtin error interface
func (e DirectFileOutputValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDirectFileOutput.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DirectFileOutputValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DirectFileOutputValidationError{}

// Validate checks the field values on ImageOutput with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ImageOutput) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ImageOutput with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ImageOutputMultiError, or
// nil if none found.
func (m *ImageOutput) ValidateAll() error {
	return m.validate(true)
}

func (m *ImageOutput) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CaptureInterval

	// no validation rules for Width

	// no validation rules for Height

	// no validation rules for FilenamePrefix

	// no validation rules for FilenameSuffix

	// no validation rules for ImageCodec

	// no validation rules for DisableManifest

	switch v := m.Output.(type) {
	case *ImageOutput_S3:
		if v == nil {
			err := ImageOutputValidationError{
				field:  "Output",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetS3()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ImageOutputValidationError{
						field:  "S3",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ImageOutputValidationError{
						field:  "S3",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetS3()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ImageOutputValidationError{
					field:  "S3",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ImageOutput_Gcp:
		if v == nil {
			err := ImageOutputValidationError{
				field:  "Output",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetGcp()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ImageOutputValidationError{
						field:  "Gcp",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ImageOutputValidationError{
						field:  "Gcp",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetGcp()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ImageOutputValidationError{
					field:  "Gcp",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ImageOutput_Azure:
		if v == nil {
			err := ImageOutputValidationError{
				field:  "Output",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetAzure()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ImageOutputValidationError{
						field:  "Azure",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ImageOutputValidationError{
						field:  "Azure",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAzure()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ImageOutputValidationError{
					field:  "Azure",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ImageOutput_AliOSS:
		if v == nil {
			err := ImageOutputValidationError{
				field:  "Output",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetAliOSS()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ImageOutputValidationError{
						field:  "AliOSS",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ImageOutputValidationError{
						field:  "AliOSS",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAliOSS()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ImageOutputValidationError{
					field:  "AliOSS",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return ImageOutputMultiError(errors)
	}

	return nil
}

// ImageOutputMultiError is an error wrapping multiple validation errors
// returned by ImageOutput.ValidateAll() if the designated constraints aren't met.
type ImageOutputMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ImageOutputMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ImageOutputMultiError) AllErrors() []error { return m }

// ImageOutputValidationError is the validation error returned by
// ImageOutput.Validate if the designated constraints aren't met.
type ImageOutputValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ImageOutputValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ImageOutputValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ImageOutputValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ImageOutputValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ImageOutputValidationError) ErrorName() string { return "ImageOutputValidationError" }

// Error satisfies the builtin error interface
func (e ImageOutputValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sImageOutput.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ImageOutputValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ImageOutputValidationError{}

// Validate checks the field values on S3Upload with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *S3Upload) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on S3Upload with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in S3UploadMultiError, or nil
// if none found.
func (m *S3Upload) ValidateAll() error {
	return m.validate(true)
}

func (m *S3Upload) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AccessKey

	// no validation rules for Secret

	// no validation rules for SessionToken

	// no validation rules for Region

	// no validation rules for Endpoint

	// no validation rules for Bucket

	// no validation rules for ForcePathStyle

	// no validation rules for Metadata

	// no validation rules for Tagging

	// no validation rules for ContentDisposition

	if all {
		switch v := interface{}(m.GetProxy()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, S3UploadValidationError{
					field:  "Proxy",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, S3UploadValidationError{
					field:  "Proxy",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetProxy()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return S3UploadValidationError{
				field:  "Proxy",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return S3UploadMultiError(errors)
	}

	return nil
}

// S3UploadMultiError is an error wrapping multiple validation errors returned
// by S3Upload.ValidateAll() if the designated constraints aren't met.
type S3UploadMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m S3UploadMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m S3UploadMultiError) AllErrors() []error { return m }

// S3UploadValidationError is the validation error returned by
// S3Upload.Validate if the designated constraints aren't met.
type S3UploadValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e S3UploadValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e S3UploadValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e S3UploadValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e S3UploadValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e S3UploadValidationError) ErrorName() string { return "S3UploadValidationError" }

// Error satisfies the builtin error interface
func (e S3UploadValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sS3Upload.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = S3UploadValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = S3UploadValidationError{}

// Validate checks the field values on GCPUpload with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GCPUpload) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GCPUpload with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GCPUploadMultiError, or nil
// if none found.
func (m *GCPUpload) ValidateAll() error {
	return m.validate(true)
}

func (m *GCPUpload) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Credentials

	// no validation rules for Bucket

	if all {
		switch v := interface{}(m.GetProxy()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GCPUploadValidationError{
					field:  "Proxy",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GCPUploadValidationError{
					field:  "Proxy",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetProxy()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GCPUploadValidationError{
				field:  "Proxy",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GCPUploadMultiError(errors)
	}

	return nil
}

// GCPUploadMultiError is an error wrapping multiple validation errors returned
// by GCPUpload.ValidateAll() if the designated constraints aren't met.
type GCPUploadMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GCPUploadMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GCPUploadMultiError) AllErrors() []error { return m }

// GCPUploadValidationError is the validation error returned by
// GCPUpload.Validate if the designated constraints aren't met.
type GCPUploadValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GCPUploadValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GCPUploadValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GCPUploadValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GCPUploadValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GCPUploadValidationError) ErrorName() string { return "GCPUploadValidationError" }

// Error satisfies the builtin error interface
func (e GCPUploadValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGCPUpload.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GCPUploadValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GCPUploadValidationError{}

// Validate checks the field values on AzureBlobUpload with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *AzureBlobUpload) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AzureBlobUpload with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AzureBlobUploadMultiError, or nil if none found.
func (m *AzureBlobUpload) ValidateAll() error {
	return m.validate(true)
}

func (m *AzureBlobUpload) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AccountName

	// no validation rules for AccountKey

	// no validation rules for ContainerName

	if len(errors) > 0 {
		return AzureBlobUploadMultiError(errors)
	}

	return nil
}

// AzureBlobUploadMultiError is an error wrapping multiple validation errors
// returned by AzureBlobUpload.ValidateAll() if the designated constraints
// aren't met.
type AzureBlobUploadMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AzureBlobUploadMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AzureBlobUploadMultiError) AllErrors() []error { return m }

// AzureBlobUploadValidationError is the validation error returned by
// AzureBlobUpload.Validate if the designated constraints aren't met.
type AzureBlobUploadValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AzureBlobUploadValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AzureBlobUploadValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AzureBlobUploadValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AzureBlobUploadValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AzureBlobUploadValidationError) ErrorName() string { return "AzureBlobUploadValidationError" }

// Error satisfies the builtin error interface
func (e AzureBlobUploadValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAzureBlobUpload.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AzureBlobUploadValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AzureBlobUploadValidationError{}

// Validate checks the field values on AliOSSUpload with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *AliOSSUpload) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AliOSSUpload with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AliOSSUploadMultiError, or
// nil if none found.
func (m *AliOSSUpload) ValidateAll() error {
	return m.validate(true)
}

func (m *AliOSSUpload) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AccessKey

	// no validation rules for Secret

	// no validation rules for Region

	// no validation rules for Endpoint

	// no validation rules for Bucket

	if len(errors) > 0 {
		return AliOSSUploadMultiError(errors)
	}

	return nil
}

// AliOSSUploadMultiError is an error wrapping multiple validation errors
// returned by AliOSSUpload.ValidateAll() if the designated constraints aren't met.
type AliOSSUploadMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AliOSSUploadMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AliOSSUploadMultiError) AllErrors() []error { return m }

// AliOSSUploadValidationError is the validation error returned by
// AliOSSUpload.Validate if the designated constraints aren't met.
type AliOSSUploadValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AliOSSUploadValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AliOSSUploadValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AliOSSUploadValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AliOSSUploadValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AliOSSUploadValidationError) ErrorName() string { return "AliOSSUploadValidationError" }

// Error satisfies the builtin error interface
func (e AliOSSUploadValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAliOSSUpload.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AliOSSUploadValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AliOSSUploadValidationError{}

// Validate checks the field values on ProxyConfig with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ProxyConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ProxyConfig with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ProxyConfigMultiError, or
// nil if none found.
func (m *ProxyConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *ProxyConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Url

	// no validation rules for Username

	// no validation rules for Password

	if len(errors) > 0 {
		return ProxyConfigMultiError(errors)
	}

	return nil
}

// ProxyConfigMultiError is an error wrapping multiple validation errors
// returned by ProxyConfig.ValidateAll() if the designated constraints aren't met.
type ProxyConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProxyConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProxyConfigMultiError) AllErrors() []error { return m }

// ProxyConfigValidationError is the validation error returned by
// ProxyConfig.Validate if the designated constraints aren't met.
type ProxyConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProxyConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProxyConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProxyConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProxyConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProxyConfigValidationError) ErrorName() string { return "ProxyConfigValidationError" }

// Error satisfies the builtin error interface
func (e ProxyConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProxyConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProxyConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProxyConfigValidationError{}

// Validate checks the field values on StreamOutput with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *StreamOutput) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StreamOutput with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in StreamOutputMultiError, or
// nil if none found.
func (m *StreamOutput) ValidateAll() error {
	return m.validate(true)
}

func (m *StreamOutput) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Protocol

	if len(errors) > 0 {
		return StreamOutputMultiError(errors)
	}

	return nil
}

// StreamOutputMultiError is an error wrapping multiple validation errors
// returned by StreamOutput.ValidateAll() if the designated constraints aren't met.
type StreamOutputMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StreamOutputMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StreamOutputMultiError) AllErrors() []error { return m }

// StreamOutputValidationError is the validation error returned by
// StreamOutput.Validate if the designated constraints aren't met.
type StreamOutputValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StreamOutputValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StreamOutputValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StreamOutputValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StreamOutputValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StreamOutputValidationError) ErrorName() string { return "StreamOutputValidationError" }

// Error satisfies the builtin error interface
func (e StreamOutputValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStreamOutput.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StreamOutputValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StreamOutputValidationError{}

// Validate checks the field values on EncodingOptions with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *EncodingOptions) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EncodingOptions with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// EncodingOptionsMultiError, or nil if none found.
func (m *EncodingOptions) ValidateAll() error {
	return m.validate(true)
}

func (m *EncodingOptions) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Width

	// no validation rules for Height

	// no validation rules for Depth

	// no validation rules for Framerate

	// no validation rules for AudioCodec

	// no validation rules for AudioBitrate

	// no validation rules for AudioQuality

	// no validation rules for AudioFrequency

	// no validation rules for VideoCodec

	// no validation rules for VideoBitrate

	// no validation rules for VideoQuality

	// no validation rules for KeyFrameInterval

	if len(errors) > 0 {
		return EncodingOptionsMultiError(errors)
	}

	return nil
}

// EncodingOptionsMultiError is an error wrapping multiple validation errors
// returned by EncodingOptions.ValidateAll() if the designated constraints
// aren't met.
type EncodingOptionsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EncodingOptionsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EncodingOptionsMultiError) AllErrors() []error { return m }

// EncodingOptionsValidationError is the validation error returned by
// EncodingOptions.Validate if the designated constraints aren't met.
type EncodingOptionsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EncodingOptionsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EncodingOptionsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EncodingOptionsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EncodingOptionsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EncodingOptionsValidationError) ErrorName() string { return "EncodingOptionsValidationError" }

// Error satisfies the builtin error interface
func (e EncodingOptionsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEncodingOptions.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EncodingOptionsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EncodingOptionsValidationError{}

// Validate checks the field values on UpdateLayoutRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateLayoutRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateLayoutRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateLayoutRequestMultiError, or nil if none found.
func (m *UpdateLayoutRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateLayoutRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for EgressId

	// no validation rules for Layout

	if len(errors) > 0 {
		return UpdateLayoutRequestMultiError(errors)
	}

	return nil
}

// UpdateLayoutRequestMultiError is an error wrapping multiple validation
// errors returned by UpdateLayoutRequest.ValidateAll() if the designated
// constraints aren't met.
type UpdateLayoutRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateLayoutRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateLayoutRequestMultiError) AllErrors() []error { return m }

// UpdateLayoutRequestValidationError is the validation error returned by
// UpdateLayoutRequest.Validate if the designated constraints aren't met.
type UpdateLayoutRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateLayoutRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateLayoutRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateLayoutRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateLayoutRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateLayoutRequestValidationError) ErrorName() string {
	return "UpdateLayoutRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateLayoutRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateLayoutRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateLayoutRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateLayoutRequestValidationError{}

// Validate checks the field values on UpdateStreamRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateStreamRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateStreamRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateStreamRequestMultiError, or nil if none found.
func (m *UpdateStreamRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateStreamRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for EgressId

	if len(errors) > 0 {
		return UpdateStreamRequestMultiError(errors)
	}

	return nil
}

// UpdateStreamRequestMultiError is an error wrapping multiple validation
// errors returned by UpdateStreamRequest.ValidateAll() if the designated
// constraints aren't met.
type UpdateStreamRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateStreamRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateStreamRequestMultiError) AllErrors() []error { return m }

// UpdateStreamRequestValidationError is the validation error returned by
// UpdateStreamRequest.Validate if the designated constraints aren't met.
type UpdateStreamRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateStreamRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateStreamRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateStreamRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateStreamRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateStreamRequestValidationError) ErrorName() string {
	return "UpdateStreamRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateStreamRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateStreamRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateStreamRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateStreamRequestValidationError{}

// Validate checks the field values on ListEgressRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListEgressRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListEgressRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListEgressRequestMultiError, or nil if none found.
func (m *ListEgressRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListEgressRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for RoomName

	// no validation rules for EgressId

	// no validation rules for Active

	if len(errors) > 0 {
		return ListEgressRequestMultiError(errors)
	}

	return nil
}

// ListEgressRequestMultiError is an error wrapping multiple validation errors
// returned by ListEgressRequest.ValidateAll() if the designated constraints
// aren't met.
type ListEgressRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListEgressRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListEgressRequestMultiError) AllErrors() []error { return m }

// ListEgressRequestValidationError is the validation error returned by
// ListEgressRequest.Validate if the designated constraints aren't met.
type ListEgressRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListEgressRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListEgressRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListEgressRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListEgressRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListEgressRequestValidationError) ErrorName() string {
	return "ListEgressRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListEgressRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListEgressRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListEgressRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListEgressRequestValidationError{}

// Validate checks the field values on ListEgressResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListEgressResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListEgressResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListEgressResponseMultiError, or nil if none found.
func (m *ListEgressResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListEgressResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListEgressResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListEgressResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListEgressResponseValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListEgressResponseMultiError(errors)
	}

	return nil
}

// ListEgressResponseMultiError is an error wrapping multiple validation errors
// returned by ListEgressResponse.ValidateAll() if the designated constraints
// aren't met.
type ListEgressResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListEgressResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListEgressResponseMultiError) AllErrors() []error { return m }

// ListEgressResponseValidationError is the validation error returned by
// ListEgressResponse.Validate if the designated constraints aren't met.
type ListEgressResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListEgressResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListEgressResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListEgressResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListEgressResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListEgressResponseValidationError) ErrorName() string {
	return "ListEgressResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListEgressResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListEgressResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListEgressResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListEgressResponseValidationError{}

// Validate checks the field values on StopEgressRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *StopEgressRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StopEgressRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// StopEgressRequestMultiError, or nil if none found.
func (m *StopEgressRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *StopEgressRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for EgressId

	if len(errors) > 0 {
		return StopEgressRequestMultiError(errors)
	}

	return nil
}

// StopEgressRequestMultiError is an error wrapping multiple validation errors
// returned by StopEgressRequest.ValidateAll() if the designated constraints
// aren't met.
type StopEgressRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StopEgressRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StopEgressRequestMultiError) AllErrors() []error { return m }

// StopEgressRequestValidationError is the validation error returned by
// StopEgressRequest.Validate if the designated constraints aren't met.
type StopEgressRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StopEgressRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StopEgressRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StopEgressRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StopEgressRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StopEgressRequestValidationError) ErrorName() string {
	return "StopEgressRequestValidationError"
}

// Error satisfies the builtin error interface
func (e StopEgressRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStopEgressRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StopEgressRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StopEgressRequestValidationError{}

// Validate checks the field values on EgressInfo with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *EgressInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EgressInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in EgressInfoMultiError, or
// nil if none found.
func (m *EgressInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *EgressInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for EgressId

	// no validation rules for RoomId

	// no validation rules for RoomName

	// no validation rules for Status

	// no validation rules for StartedAt

	// no validation rules for EndedAt

	// no validation rules for UpdatedAt

	// no validation rules for Details

	// no validation rules for Error

	// no validation rules for ErrorCode

	for idx, item := range m.GetStreamResults() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EgressInfoValidationError{
						field:  fmt.Sprintf("StreamResults[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EgressInfoValidationError{
						field:  fmt.Sprintf("StreamResults[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EgressInfoValidationError{
					field:  fmt.Sprintf("StreamResults[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetFileResults() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EgressInfoValidationError{
						field:  fmt.Sprintf("FileResults[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EgressInfoValidationError{
						field:  fmt.Sprintf("FileResults[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EgressInfoValidationError{
					field:  fmt.Sprintf("FileResults[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetSegmentResults() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EgressInfoValidationError{
						field:  fmt.Sprintf("SegmentResults[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EgressInfoValidationError{
						field:  fmt.Sprintf("SegmentResults[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EgressInfoValidationError{
					field:  fmt.Sprintf("SegmentResults[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetImageResults() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EgressInfoValidationError{
						field:  fmt.Sprintf("ImageResults[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EgressInfoValidationError{
						field:  fmt.Sprintf("ImageResults[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EgressInfoValidationError{
					field:  fmt.Sprintf("ImageResults[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	switch v := m.Request.(type) {
	case *EgressInfo_RoomComposite:
		if v == nil {
			err := EgressInfoValidationError{
				field:  "Request",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetRoomComposite()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EgressInfoValidationError{
						field:  "RoomComposite",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EgressInfoValidationError{
						field:  "RoomComposite",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRoomComposite()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EgressInfoValidationError{
					field:  "RoomComposite",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *EgressInfo_Web:
		if v == nil {
			err := EgressInfoValidationError{
				field:  "Request",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetWeb()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EgressInfoValidationError{
						field:  "Web",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EgressInfoValidationError{
						field:  "Web",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetWeb()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EgressInfoValidationError{
					field:  "Web",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *EgressInfo_Participant:
		if v == nil {
			err := EgressInfoValidationError{
				field:  "Request",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetParticipant()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EgressInfoValidationError{
						field:  "Participant",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EgressInfoValidationError{
						field:  "Participant",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetParticipant()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EgressInfoValidationError{
					field:  "Participant",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *EgressInfo_TrackComposite:
		if v == nil {
			err := EgressInfoValidationError{
				field:  "Request",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetTrackComposite()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EgressInfoValidationError{
						field:  "TrackComposite",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EgressInfoValidationError{
						field:  "TrackComposite",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTrackComposite()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EgressInfoValidationError{
					field:  "TrackComposite",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *EgressInfo_Track:
		if v == nil {
			err := EgressInfoValidationError{
				field:  "Request",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetTrack()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EgressInfoValidationError{
						field:  "Track",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EgressInfoValidationError{
						field:  "Track",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTrack()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EgressInfoValidationError{
					field:  "Track",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}
	switch v := m.Result.(type) {
	case *EgressInfo_Stream:
		if v == nil {
			err := EgressInfoValidationError{
				field:  "Result",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetStream()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EgressInfoValidationError{
						field:  "Stream",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EgressInfoValidationError{
						field:  "Stream",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetStream()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EgressInfoValidationError{
					field:  "Stream",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *EgressInfo_File:
		if v == nil {
			err := EgressInfoValidationError{
				field:  "Result",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetFile()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EgressInfoValidationError{
						field:  "File",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EgressInfoValidationError{
						field:  "File",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetFile()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EgressInfoValidationError{
					field:  "File",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *EgressInfo_Segments:
		if v == nil {
			err := EgressInfoValidationError{
				field:  "Result",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetSegments()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EgressInfoValidationError{
						field:  "Segments",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EgressInfoValidationError{
						field:  "Segments",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSegments()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EgressInfoValidationError{
					field:  "Segments",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return EgressInfoMultiError(errors)
	}

	return nil
}

// EgressInfoMultiError is an error wrapping multiple validation errors
// returned by EgressInfo.ValidateAll() if the designated constraints aren't met.
type EgressInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EgressInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EgressInfoMultiError) AllErrors() []error { return m }

// EgressInfoValidationError is the validation error returned by
// EgressInfo.Validate if the designated constraints aren't met.
type EgressInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EgressInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EgressInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EgressInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EgressInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EgressInfoValidationError) ErrorName() string { return "EgressInfoValidationError" }

// Error satisfies the builtin error interface
func (e EgressInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEgressInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EgressInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EgressInfoValidationError{}

// Validate checks the field values on StreamInfoList with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *StreamInfoList) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StreamInfoList with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in StreamInfoListMultiError,
// or nil if none found.
func (m *StreamInfoList) ValidateAll() error {
	return m.validate(true)
}

func (m *StreamInfoList) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetInfo() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StreamInfoListValidationError{
						field:  fmt.Sprintf("Info[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StreamInfoListValidationError{
						field:  fmt.Sprintf("Info[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StreamInfoListValidationError{
					field:  fmt.Sprintf("Info[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return StreamInfoListMultiError(errors)
	}

	return nil
}

// StreamInfoListMultiError is an error wrapping multiple validation errors
// returned by StreamInfoList.ValidateAll() if the designated constraints
// aren't met.
type StreamInfoListMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StreamInfoListMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StreamInfoListMultiError) AllErrors() []error { return m }

// StreamInfoListValidationError is the validation error returned by
// StreamInfoList.Validate if the designated constraints aren't met.
type StreamInfoListValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StreamInfoListValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StreamInfoListValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StreamInfoListValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StreamInfoListValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StreamInfoListValidationError) ErrorName() string { return "StreamInfoListValidationError" }

// Error satisfies the builtin error interface
func (e StreamInfoListValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStreamInfoList.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StreamInfoListValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StreamInfoListValidationError{}

// Validate checks the field values on StreamInfo with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *StreamInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StreamInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in StreamInfoMultiError, or
// nil if none found.
func (m *StreamInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *StreamInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Url

	// no validation rules for StartedAt

	// no validation rules for EndedAt

	// no validation rules for Duration

	// no validation rules for Status

	// no validation rules for Error

	if len(errors) > 0 {
		return StreamInfoMultiError(errors)
	}

	return nil
}

// StreamInfoMultiError is an error wrapping multiple validation errors
// returned by StreamInfo.ValidateAll() if the designated constraints aren't met.
type StreamInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StreamInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StreamInfoMultiError) AllErrors() []error { return m }

// StreamInfoValidationError is the validation error returned by
// StreamInfo.Validate if the designated constraints aren't met.
type StreamInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StreamInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StreamInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StreamInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StreamInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StreamInfoValidationError) ErrorName() string { return "StreamInfoValidationError" }

// Error satisfies the builtin error interface
func (e StreamInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStreamInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StreamInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StreamInfoValidationError{}

// Validate checks the field values on FileInfo with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *FileInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FileInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in FileInfoMultiError, or nil
// if none found.
func (m *FileInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *FileInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Filename

	// no validation rules for StartedAt

	// no validation rules for EndedAt

	// no validation rules for Duration

	// no validation rules for Size

	// no validation rules for Location

	if len(errors) > 0 {
		return FileInfoMultiError(errors)
	}

	return nil
}

// FileInfoMultiError is an error wrapping multiple validation errors returned
// by FileInfo.ValidateAll() if the designated constraints aren't met.
type FileInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FileInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FileInfoMultiError) AllErrors() []error { return m }

// FileInfoValidationError is the validation error returned by
// FileInfo.Validate if the designated constraints aren't met.
type FileInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FileInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FileInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FileInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FileInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FileInfoValidationError) ErrorName() string { return "FileInfoValidationError" }

// Error satisfies the builtin error interface
func (e FileInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFileInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FileInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FileInfoValidationError{}

// Validate checks the field values on SegmentsInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SegmentsInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SegmentsInfo with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SegmentsInfoMultiError, or
// nil if none found.
func (m *SegmentsInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *SegmentsInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PlaylistName

	// no validation rules for LivePlaylistName

	// no validation rules for Duration

	// no validation rules for Size

	// no validation rules for PlaylistLocation

	// no validation rules for LivePlaylistLocation

	// no validation rules for SegmentCount

	// no validation rules for StartedAt

	// no validation rules for EndedAt

	if len(errors) > 0 {
		return SegmentsInfoMultiError(errors)
	}

	return nil
}

// SegmentsInfoMultiError is an error wrapping multiple validation errors
// returned by SegmentsInfo.ValidateAll() if the designated constraints aren't met.
type SegmentsInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SegmentsInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SegmentsInfoMultiError) AllErrors() []error { return m }

// SegmentsInfoValidationError is the validation error returned by
// SegmentsInfo.Validate if the designated constraints aren't met.
type SegmentsInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SegmentsInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SegmentsInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SegmentsInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SegmentsInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SegmentsInfoValidationError) ErrorName() string { return "SegmentsInfoValidationError" }

// Error satisfies the builtin error interface
func (e SegmentsInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSegmentsInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SegmentsInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SegmentsInfoValidationError{}

// Validate checks the field values on ImagesInfo with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ImagesInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ImagesInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ImagesInfoMultiError, or
// nil if none found.
func (m *ImagesInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *ImagesInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for FilenamePrefix

	// no validation rules for ImageCount

	// no validation rules for StartedAt

	// no validation rules for EndedAt

	if len(errors) > 0 {
		return ImagesInfoMultiError(errors)
	}

	return nil
}

// ImagesInfoMultiError is an error wrapping multiple validation errors
// returned by ImagesInfo.ValidateAll() if the designated constraints aren't met.
type ImagesInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ImagesInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ImagesInfoMultiError) AllErrors() []error { return m }

// ImagesInfoValidationError is the validation error returned by
// ImagesInfo.Validate if the designated constraints aren't met.
type ImagesInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ImagesInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ImagesInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ImagesInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ImagesInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ImagesInfoValidationError) ErrorName() string { return "ImagesInfoValidationError" }

// Error satisfies the builtin error interface
func (e ImagesInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sImagesInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ImagesInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ImagesInfoValidationError{}

// Validate checks the field values on AutoParticipantEgress with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AutoParticipantEgress) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AutoParticipantEgress with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AutoParticipantEgressMultiError, or nil if none found.
func (m *AutoParticipantEgress) ValidateAll() error {
	return m.validate(true)
}

func (m *AutoParticipantEgress) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetFileOutputs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AutoParticipantEgressValidationError{
						field:  fmt.Sprintf("FileOutputs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AutoParticipantEgressValidationError{
						field:  fmt.Sprintf("FileOutputs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AutoParticipantEgressValidationError{
					field:  fmt.Sprintf("FileOutputs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetSegmentOutputs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AutoParticipantEgressValidationError{
						field:  fmt.Sprintf("SegmentOutputs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AutoParticipantEgressValidationError{
						field:  fmt.Sprintf("SegmentOutputs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AutoParticipantEgressValidationError{
					field:  fmt.Sprintf("SegmentOutputs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	switch v := m.Options.(type) {
	case *AutoParticipantEgress_Preset:
		if v == nil {
			err := AutoParticipantEgressValidationError{
				field:  "Options",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for Preset
	case *AutoParticipantEgress_Advanced:
		if v == nil {
			err := AutoParticipantEgressValidationError{
				field:  "Options",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetAdvanced()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AutoParticipantEgressValidationError{
						field:  "Advanced",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AutoParticipantEgressValidationError{
						field:  "Advanced",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAdvanced()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AutoParticipantEgressValidationError{
					field:  "Advanced",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return AutoParticipantEgressMultiError(errors)
	}

	return nil
}

// AutoParticipantEgressMultiError is an error wrapping multiple validation
// errors returned by AutoParticipantEgress.ValidateAll() if the designated
// constraints aren't met.
type AutoParticipantEgressMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AutoParticipantEgressMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AutoParticipantEgressMultiError) AllErrors() []error { return m }

// AutoParticipantEgressValidationError is the validation error returned by
// AutoParticipantEgress.Validate if the designated constraints aren't met.
type AutoParticipantEgressValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AutoParticipantEgressValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AutoParticipantEgressValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AutoParticipantEgressValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AutoParticipantEgressValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AutoParticipantEgressValidationError) ErrorName() string {
	return "AutoParticipantEgressValidationError"
}

// Error satisfies the builtin error interface
func (e AutoParticipantEgressValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAutoParticipantEgress.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AutoParticipantEgressValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AutoParticipantEgressValidationError{}

// Validate checks the field values on AutoTrackEgress with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *AutoTrackEgress) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AutoTrackEgress with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AutoTrackEgressMultiError, or nil if none found.
func (m *AutoTrackEgress) ValidateAll() error {
	return m.validate(true)
}

func (m *AutoTrackEgress) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Filepath

	// no validation rules for DisableManifest

	switch v := m.Output.(type) {
	case *AutoTrackEgress_S3:
		if v == nil {
			err := AutoTrackEgressValidationError{
				field:  "Output",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetS3()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AutoTrackEgressValidationError{
						field:  "S3",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AutoTrackEgressValidationError{
						field:  "S3",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetS3()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AutoTrackEgressValidationError{
					field:  "S3",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *AutoTrackEgress_Gcp:
		if v == nil {
			err := AutoTrackEgressValidationError{
				field:  "Output",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetGcp()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AutoTrackEgressValidationError{
						field:  "Gcp",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AutoTrackEgressValidationError{
						field:  "Gcp",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetGcp()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AutoTrackEgressValidationError{
					field:  "Gcp",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *AutoTrackEgress_Azure:
		if v == nil {
			err := AutoTrackEgressValidationError{
				field:  "Output",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetAzure()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AutoTrackEgressValidationError{
						field:  "Azure",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AutoTrackEgressValidationError{
						field:  "Azure",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAzure()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AutoTrackEgressValidationError{
					field:  "Azure",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *AutoTrackEgress_AliOSS:
		if v == nil {
			err := AutoTrackEgressValidationError{
				field:  "Output",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetAliOSS()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AutoTrackEgressValidationError{
						field:  "AliOSS",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AutoTrackEgressValidationError{
						field:  "AliOSS",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAliOSS()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AutoTrackEgressValidationError{
					field:  "AliOSS",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return AutoTrackEgressMultiError(errors)
	}

	return nil
}

// AutoTrackEgressMultiError is an error wrapping multiple validation errors
// returned by AutoTrackEgress.ValidateAll() if the designated constraints
// aren't met.
type AutoTrackEgressMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AutoTrackEgressMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AutoTrackEgressMultiError) AllErrors() []error { return m }

// AutoTrackEgressValidationError is the validation error returned by
// AutoTrackEgress.Validate if the designated constraints aren't met.
type AutoTrackEgressValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AutoTrackEgressValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AutoTrackEgressValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AutoTrackEgressValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AutoTrackEgressValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AutoTrackEgressValidationError) ErrorName() string { return "AutoTrackEgressValidationError" }

// Error satisfies the builtin error interface
func (e AutoTrackEgressValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAutoTrackEgress.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AutoTrackEgressValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AutoTrackEgressValidationError{}
