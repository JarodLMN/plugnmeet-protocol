// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: livekit_models.proto

package livekit

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on Room with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Room) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Room with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in RoomMultiError, or nil if none found.
func (m *Room) ValidateAll() error {
	return m.validate(true)
}

func (m *Room) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Sid

	// no validation rules for Name

	// no validation rules for EmptyTimeout

	// no validation rules for DepartureTimeout

	// no validation rules for MaxParticipants

	// no validation rules for CreationTime

	// no validation rules for TurnPassword

	for idx, item := range m.GetEnabledCodecs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RoomValidationError{
						field:  fmt.Sprintf("EnabledCodecs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RoomValidationError{
						field:  fmt.Sprintf("EnabledCodecs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RoomValidationError{
					field:  fmt.Sprintf("EnabledCodecs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Metadata

	// no validation rules for NumParticipants

	// no validation rules for NumPublishers

	// no validation rules for ActiveRecording

	if all {
		switch v := interface{}(m.GetVersion()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RoomValidationError{
					field:  "Version",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RoomValidationError{
					field:  "Version",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetVersion()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RoomValidationError{
				field:  "Version",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return RoomMultiError(errors)
	}

	return nil
}

// RoomMultiError is an error wrapping multiple validation errors returned by
// Room.ValidateAll() if the designated constraints aren't met.
type RoomMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RoomMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RoomMultiError) AllErrors() []error { return m }

// RoomValidationError is the validation error returned by Room.Validate if the
// designated constraints aren't met.
type RoomValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RoomValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RoomValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RoomValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RoomValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RoomValidationError) ErrorName() string { return "RoomValidationError" }

// Error satisfies the builtin error interface
func (e RoomValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRoom.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RoomValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RoomValidationError{}

// Validate checks the field values on Codec with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Codec) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Codec with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in CodecMultiError, or nil if none found.
func (m *Codec) ValidateAll() error {
	return m.validate(true)
}

func (m *Codec) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Mime

	// no validation rules for FmtpLine

	if len(errors) > 0 {
		return CodecMultiError(errors)
	}

	return nil
}

// CodecMultiError is an error wrapping multiple validation errors returned by
// Codec.ValidateAll() if the designated constraints aren't met.
type CodecMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CodecMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CodecMultiError) AllErrors() []error { return m }

// CodecValidationError is the validation error returned by Codec.Validate if
// the designated constraints aren't met.
type CodecValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CodecValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CodecValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CodecValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CodecValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CodecValidationError) ErrorName() string { return "CodecValidationError" }

// Error satisfies the builtin error interface
func (e CodecValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCodec.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CodecValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CodecValidationError{}

// Validate checks the field values on PlayoutDelay with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PlayoutDelay) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PlayoutDelay with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PlayoutDelayMultiError, or
// nil if none found.
func (m *PlayoutDelay) ValidateAll() error {
	return m.validate(true)
}

func (m *PlayoutDelay) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Enabled

	// no validation rules for Min

	// no validation rules for Max

	if len(errors) > 0 {
		return PlayoutDelayMultiError(errors)
	}

	return nil
}

// PlayoutDelayMultiError is an error wrapping multiple validation errors
// returned by PlayoutDelay.ValidateAll() if the designated constraints aren't met.
type PlayoutDelayMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PlayoutDelayMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PlayoutDelayMultiError) AllErrors() []error { return m }

// PlayoutDelayValidationError is the validation error returned by
// PlayoutDelay.Validate if the designated constraints aren't met.
type PlayoutDelayValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PlayoutDelayValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PlayoutDelayValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PlayoutDelayValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PlayoutDelayValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PlayoutDelayValidationError) ErrorName() string { return "PlayoutDelayValidationError" }

// Error satisfies the builtin error interface
func (e PlayoutDelayValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPlayoutDelay.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PlayoutDelayValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PlayoutDelayValidationError{}

// Validate checks the field values on ParticipantPermission with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ParticipantPermission) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ParticipantPermission with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ParticipantPermissionMultiError, or nil if none found.
func (m *ParticipantPermission) ValidateAll() error {
	return m.validate(true)
}

func (m *ParticipantPermission) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CanSubscribe

	// no validation rules for CanPublish

	// no validation rules for CanPublishData

	// no validation rules for Hidden

	// no validation rules for Recorder

	// no validation rules for CanUpdateMetadata

	// no validation rules for Agent

	if len(errors) > 0 {
		return ParticipantPermissionMultiError(errors)
	}

	return nil
}

// ParticipantPermissionMultiError is an error wrapping multiple validation
// errors returned by ParticipantPermission.ValidateAll() if the designated
// constraints aren't met.
type ParticipantPermissionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ParticipantPermissionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ParticipantPermissionMultiError) AllErrors() []error { return m }

// ParticipantPermissionValidationError is the validation error returned by
// ParticipantPermission.Validate if the designated constraints aren't met.
type ParticipantPermissionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ParticipantPermissionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ParticipantPermissionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ParticipantPermissionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ParticipantPermissionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ParticipantPermissionValidationError) ErrorName() string {
	return "ParticipantPermissionValidationError"
}

// Error satisfies the builtin error interface
func (e ParticipantPermissionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sParticipantPermission.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ParticipantPermissionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ParticipantPermissionValidationError{}

// Validate checks the field values on ParticipantInfo with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ParticipantInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ParticipantInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ParticipantInfoMultiError, or nil if none found.
func (m *ParticipantInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *ParticipantInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Sid

	// no validation rules for Identity

	// no validation rules for State

	for idx, item := range m.GetTracks() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ParticipantInfoValidationError{
						field:  fmt.Sprintf("Tracks[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ParticipantInfoValidationError{
						field:  fmt.Sprintf("Tracks[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ParticipantInfoValidationError{
					field:  fmt.Sprintf("Tracks[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Metadata

	// no validation rules for JoinedAt

	// no validation rules for Name

	// no validation rules for Version

	if all {
		switch v := interface{}(m.GetPermission()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ParticipantInfoValidationError{
					field:  "Permission",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ParticipantInfoValidationError{
					field:  "Permission",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPermission()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ParticipantInfoValidationError{
				field:  "Permission",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Region

	// no validation rules for IsPublisher

	// no validation rules for Kind

	// no validation rules for Attributes

	// no validation rules for DisconnectReason

	if len(errors) > 0 {
		return ParticipantInfoMultiError(errors)
	}

	return nil
}

// ParticipantInfoMultiError is an error wrapping multiple validation errors
// returned by ParticipantInfo.ValidateAll() if the designated constraints
// aren't met.
type ParticipantInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ParticipantInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ParticipantInfoMultiError) AllErrors() []error { return m }

// ParticipantInfoValidationError is the validation error returned by
// ParticipantInfo.Validate if the designated constraints aren't met.
type ParticipantInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ParticipantInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ParticipantInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ParticipantInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ParticipantInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ParticipantInfoValidationError) ErrorName() string { return "ParticipantInfoValidationError" }

// Error satisfies the builtin error interface
func (e ParticipantInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sParticipantInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ParticipantInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ParticipantInfoValidationError{}

// Validate checks the field values on Encryption with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Encryption) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Encryption with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in EncryptionMultiError, or
// nil if none found.
func (m *Encryption) ValidateAll() error {
	return m.validate(true)
}

func (m *Encryption) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return EncryptionMultiError(errors)
	}

	return nil
}

// EncryptionMultiError is an error wrapping multiple validation errors
// returned by Encryption.ValidateAll() if the designated constraints aren't met.
type EncryptionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EncryptionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EncryptionMultiError) AllErrors() []error { return m }

// EncryptionValidationError is the validation error returned by
// Encryption.Validate if the designated constraints aren't met.
type EncryptionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EncryptionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EncryptionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EncryptionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EncryptionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EncryptionValidationError) ErrorName() string { return "EncryptionValidationError" }

// Error satisfies the builtin error interface
func (e EncryptionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEncryption.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EncryptionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EncryptionValidationError{}

// Validate checks the field values on SimulcastCodecInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SimulcastCodecInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SimulcastCodecInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SimulcastCodecInfoMultiError, or nil if none found.
func (m *SimulcastCodecInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *SimulcastCodecInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for MimeType

	// no validation rules for Mid

	// no validation rules for Cid

	for idx, item := range m.GetLayers() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SimulcastCodecInfoValidationError{
						field:  fmt.Sprintf("Layers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SimulcastCodecInfoValidationError{
						field:  fmt.Sprintf("Layers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SimulcastCodecInfoValidationError{
					field:  fmt.Sprintf("Layers[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return SimulcastCodecInfoMultiError(errors)
	}

	return nil
}

// SimulcastCodecInfoMultiError is an error wrapping multiple validation errors
// returned by SimulcastCodecInfo.ValidateAll() if the designated constraints
// aren't met.
type SimulcastCodecInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SimulcastCodecInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SimulcastCodecInfoMultiError) AllErrors() []error { return m }

// SimulcastCodecInfoValidationError is the validation error returned by
// SimulcastCodecInfo.Validate if the designated constraints aren't met.
type SimulcastCodecInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SimulcastCodecInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SimulcastCodecInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SimulcastCodecInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SimulcastCodecInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SimulcastCodecInfoValidationError) ErrorName() string {
	return "SimulcastCodecInfoValidationError"
}

// Error satisfies the builtin error interface
func (e SimulcastCodecInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSimulcastCodecInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SimulcastCodecInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SimulcastCodecInfoValidationError{}

// Validate checks the field values on TrackInfo with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TrackInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TrackInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TrackInfoMultiError, or nil
// if none found.
func (m *TrackInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *TrackInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Sid

	// no validation rules for Type

	// no validation rules for Name

	// no validation rules for Muted

	// no validation rules for Width

	// no validation rules for Height

	// no validation rules for Simulcast

	// no validation rules for DisableDtx

	// no validation rules for Source

	for idx, item := range m.GetLayers() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TrackInfoValidationError{
						field:  fmt.Sprintf("Layers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TrackInfoValidationError{
						field:  fmt.Sprintf("Layers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TrackInfoValidationError{
					field:  fmt.Sprintf("Layers[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for MimeType

	// no validation rules for Mid

	for idx, item := range m.GetCodecs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TrackInfoValidationError{
						field:  fmt.Sprintf("Codecs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TrackInfoValidationError{
						field:  fmt.Sprintf("Codecs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TrackInfoValidationError{
					field:  fmt.Sprintf("Codecs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Stereo

	// no validation rules for DisableRed

	// no validation rules for Encryption

	// no validation rules for Stream

	if all {
		switch v := interface{}(m.GetVersion()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TrackInfoValidationError{
					field:  "Version",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TrackInfoValidationError{
					field:  "Version",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetVersion()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TrackInfoValidationError{
				field:  "Version",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return TrackInfoMultiError(errors)
	}

	return nil
}

// TrackInfoMultiError is an error wrapping multiple validation errors returned
// by TrackInfo.ValidateAll() if the designated constraints aren't met.
type TrackInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TrackInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TrackInfoMultiError) AllErrors() []error { return m }

// TrackInfoValidationError is the validation error returned by
// TrackInfo.Validate if the designated constraints aren't met.
type TrackInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TrackInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TrackInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TrackInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TrackInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TrackInfoValidationError) ErrorName() string { return "TrackInfoValidationError" }

// Error satisfies the builtin error interface
func (e TrackInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTrackInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TrackInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TrackInfoValidationError{}

// Validate checks the field values on VideoLayer with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *VideoLayer) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on VideoLayer with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in VideoLayerMultiError, or
// nil if none found.
func (m *VideoLayer) ValidateAll() error {
	return m.validate(true)
}

func (m *VideoLayer) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Quality

	// no validation rules for Width

	// no validation rules for Height

	// no validation rules for Bitrate

	// no validation rules for Ssrc

	if len(errors) > 0 {
		return VideoLayerMultiError(errors)
	}

	return nil
}

// VideoLayerMultiError is an error wrapping multiple validation errors
// returned by VideoLayer.ValidateAll() if the designated constraints aren't met.
type VideoLayerMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m VideoLayerMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m VideoLayerMultiError) AllErrors() []error { return m }

// VideoLayerValidationError is the validation error returned by
// VideoLayer.Validate if the designated constraints aren't met.
type VideoLayerValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e VideoLayerValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e VideoLayerValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e VideoLayerValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e VideoLayerValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e VideoLayerValidationError) ErrorName() string { return "VideoLayerValidationError" }

// Error satisfies the builtin error interface
func (e VideoLayerValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sVideoLayer.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = VideoLayerValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = VideoLayerValidationError{}

// Validate checks the field values on DataPacket with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DataPacket) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DataPacket with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DataPacketMultiError, or
// nil if none found.
func (m *DataPacket) ValidateAll() error {
	return m.validate(true)
}

func (m *DataPacket) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Kind

	// no validation rules for ParticipantIdentity

	switch v := m.Value.(type) {
	case *DataPacket_User:
		if v == nil {
			err := DataPacketValidationError{
				field:  "Value",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetUser()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DataPacketValidationError{
						field:  "User",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DataPacketValidationError{
						field:  "User",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetUser()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DataPacketValidationError{
					field:  "User",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *DataPacket_Speaker:
		if v == nil {
			err := DataPacketValidationError{
				field:  "Value",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetSpeaker()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DataPacketValidationError{
						field:  "Speaker",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DataPacketValidationError{
						field:  "Speaker",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSpeaker()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DataPacketValidationError{
					field:  "Speaker",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *DataPacket_SipDtmf:
		if v == nil {
			err := DataPacketValidationError{
				field:  "Value",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetSipDtmf()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DataPacketValidationError{
						field:  "SipDtmf",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DataPacketValidationError{
						field:  "SipDtmf",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSipDtmf()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DataPacketValidationError{
					field:  "SipDtmf",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *DataPacket_Transcription:
		if v == nil {
			err := DataPacketValidationError{
				field:  "Value",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetTranscription()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DataPacketValidationError{
						field:  "Transcription",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DataPacketValidationError{
						field:  "Transcription",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTranscription()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DataPacketValidationError{
					field:  "Transcription",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *DataPacket_Metrics:
		if v == nil {
			err := DataPacketValidationError{
				field:  "Value",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetMetrics()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DataPacketValidationError{
						field:  "Metrics",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DataPacketValidationError{
						field:  "Metrics",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetMetrics()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DataPacketValidationError{
					field:  "Metrics",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return DataPacketMultiError(errors)
	}

	return nil
}

// DataPacketMultiError is an error wrapping multiple validation errors
// returned by DataPacket.ValidateAll() if the designated constraints aren't met.
type DataPacketMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DataPacketMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DataPacketMultiError) AllErrors() []error { return m }

// DataPacketValidationError is the validation error returned by
// DataPacket.Validate if the designated constraints aren't met.
type DataPacketValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DataPacketValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DataPacketValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DataPacketValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DataPacketValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DataPacketValidationError) ErrorName() string { return "DataPacketValidationError" }

// Error satisfies the builtin error interface
func (e DataPacketValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDataPacket.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DataPacketValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DataPacketValidationError{}

// Validate checks the field values on ActiveSpeakerUpdate with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ActiveSpeakerUpdate) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ActiveSpeakerUpdate with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ActiveSpeakerUpdateMultiError, or nil if none found.
func (m *ActiveSpeakerUpdate) ValidateAll() error {
	return m.validate(true)
}

func (m *ActiveSpeakerUpdate) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetSpeakers() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ActiveSpeakerUpdateValidationError{
						field:  fmt.Sprintf("Speakers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ActiveSpeakerUpdateValidationError{
						field:  fmt.Sprintf("Speakers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ActiveSpeakerUpdateValidationError{
					field:  fmt.Sprintf("Speakers[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ActiveSpeakerUpdateMultiError(errors)
	}

	return nil
}

// ActiveSpeakerUpdateMultiError is an error wrapping multiple validation
// errors returned by ActiveSpeakerUpdate.ValidateAll() if the designated
// constraints aren't met.
type ActiveSpeakerUpdateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ActiveSpeakerUpdateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ActiveSpeakerUpdateMultiError) AllErrors() []error { return m }

// ActiveSpeakerUpdateValidationError is the validation error returned by
// ActiveSpeakerUpdate.Validate if the designated constraints aren't met.
type ActiveSpeakerUpdateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ActiveSpeakerUpdateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ActiveSpeakerUpdateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ActiveSpeakerUpdateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ActiveSpeakerUpdateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ActiveSpeakerUpdateValidationError) ErrorName() string {
	return "ActiveSpeakerUpdateValidationError"
}

// Error satisfies the builtin error interface
func (e ActiveSpeakerUpdateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sActiveSpeakerUpdate.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ActiveSpeakerUpdateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ActiveSpeakerUpdateValidationError{}

// Validate checks the field values on SpeakerInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SpeakerInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SpeakerInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SpeakerInfoMultiError, or
// nil if none found.
func (m *SpeakerInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *SpeakerInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Sid

	// no validation rules for Level

	// no validation rules for Active

	if len(errors) > 0 {
		return SpeakerInfoMultiError(errors)
	}

	return nil
}

// SpeakerInfoMultiError is an error wrapping multiple validation errors
// returned by SpeakerInfo.ValidateAll() if the designated constraints aren't met.
type SpeakerInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SpeakerInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SpeakerInfoMultiError) AllErrors() []error { return m }

// SpeakerInfoValidationError is the validation error returned by
// SpeakerInfo.Validate if the designated constraints aren't met.
type SpeakerInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SpeakerInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SpeakerInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SpeakerInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SpeakerInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SpeakerInfoValidationError) ErrorName() string { return "SpeakerInfoValidationError" }

// Error satisfies the builtin error interface
func (e SpeakerInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSpeakerInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SpeakerInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SpeakerInfoValidationError{}

// Validate checks the field values on UserPacket with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UserPacket) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserPacket with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UserPacketMultiError, or
// nil if none found.
func (m *UserPacket) ValidateAll() error {
	return m.validate(true)
}

func (m *UserPacket) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ParticipantSid

	// no validation rules for ParticipantIdentity

	// no validation rules for Payload

	if m.Topic != nil {
		// no validation rules for Topic
	}

	if m.Id != nil {
		// no validation rules for Id
	}

	if m.StartTime != nil {
		// no validation rules for StartTime
	}

	if m.EndTime != nil {
		// no validation rules for EndTime
	}

	if len(errors) > 0 {
		return UserPacketMultiError(errors)
	}

	return nil
}

// UserPacketMultiError is an error wrapping multiple validation errors
// returned by UserPacket.ValidateAll() if the designated constraints aren't met.
type UserPacketMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserPacketMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserPacketMultiError) AllErrors() []error { return m }

// UserPacketValidationError is the validation error returned by
// UserPacket.Validate if the designated constraints aren't met.
type UserPacketValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserPacketValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserPacketValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserPacketValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserPacketValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserPacketValidationError) ErrorName() string { return "UserPacketValidationError" }

// Error satisfies the builtin error interface
func (e UserPacketValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserPacket.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserPacketValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserPacketValidationError{}

// Validate checks the field values on SipDTMF with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SipDTMF) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SipDTMF with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in SipDTMFMultiError, or nil if none found.
func (m *SipDTMF) ValidateAll() error {
	return m.validate(true)
}

func (m *SipDTMF) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Digit

	if len(errors) > 0 {
		return SipDTMFMultiError(errors)
	}

	return nil
}

// SipDTMFMultiError is an error wrapping multiple validation errors returned
// by SipDTMF.ValidateAll() if the designated constraints aren't met.
type SipDTMFMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SipDTMFMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SipDTMFMultiError) AllErrors() []error { return m }

// SipDTMFValidationError is the validation error returned by SipDTMF.Validate
// if the designated constraints aren't met.
type SipDTMFValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SipDTMFValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SipDTMFValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SipDTMFValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SipDTMFValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SipDTMFValidationError) ErrorName() string { return "SipDTMFValidationError" }

// Error satisfies the builtin error interface
func (e SipDTMFValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSipDTMF.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SipDTMFValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SipDTMFValidationError{}

// Validate checks the field values on Transcription with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Transcription) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Transcription with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TranscriptionMultiError, or
// nil if none found.
func (m *Transcription) ValidateAll() error {
	return m.validate(true)
}

func (m *Transcription) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TranscribedParticipantIdentity

	// no validation rules for TrackId

	for idx, item := range m.GetSegments() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TranscriptionValidationError{
						field:  fmt.Sprintf("Segments[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TranscriptionValidationError{
						field:  fmt.Sprintf("Segments[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TranscriptionValidationError{
					field:  fmt.Sprintf("Segments[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return TranscriptionMultiError(errors)
	}

	return nil
}

// TranscriptionMultiError is an error wrapping multiple validation errors
// returned by Transcription.ValidateAll() if the designated constraints
// aren't met.
type TranscriptionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TranscriptionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TranscriptionMultiError) AllErrors() []error { return m }

// TranscriptionValidationError is the validation error returned by
// Transcription.Validate if the designated constraints aren't met.
type TranscriptionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TranscriptionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TranscriptionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TranscriptionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TranscriptionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TranscriptionValidationError) ErrorName() string { return "TranscriptionValidationError" }

// Error satisfies the builtin error interface
func (e TranscriptionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTranscription.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TranscriptionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TranscriptionValidationError{}

// Validate checks the field values on TranscriptionSegment with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TranscriptionSegment) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TranscriptionSegment with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TranscriptionSegmentMultiError, or nil if none found.
func (m *TranscriptionSegment) ValidateAll() error {
	return m.validate(true)
}

func (m *TranscriptionSegment) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Text

	// no validation rules for StartTime

	// no validation rules for EndTime

	// no validation rules for Final

	// no validation rules for Language

	if len(errors) > 0 {
		return TranscriptionSegmentMultiError(errors)
	}

	return nil
}

// TranscriptionSegmentMultiError is an error wrapping multiple validation
// errors returned by TranscriptionSegment.ValidateAll() if the designated
// constraints aren't met.
type TranscriptionSegmentMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TranscriptionSegmentMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TranscriptionSegmentMultiError) AllErrors() []error { return m }

// TranscriptionSegmentValidationError is the validation error returned by
// TranscriptionSegment.Validate if the designated constraints aren't met.
type TranscriptionSegmentValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TranscriptionSegmentValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TranscriptionSegmentValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TranscriptionSegmentValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TranscriptionSegmentValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TranscriptionSegmentValidationError) ErrorName() string {
	return "TranscriptionSegmentValidationError"
}

// Error satisfies the builtin error interface
func (e TranscriptionSegmentValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTranscriptionSegment.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TranscriptionSegmentValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TranscriptionSegmentValidationError{}

// Validate checks the field values on ParticipantTracks with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ParticipantTracks) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ParticipantTracks with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ParticipantTracksMultiError, or nil if none found.
func (m *ParticipantTracks) ValidateAll() error {
	return m.validate(true)
}

func (m *ParticipantTracks) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ParticipantSid

	if len(errors) > 0 {
		return ParticipantTracksMultiError(errors)
	}

	return nil
}

// ParticipantTracksMultiError is an error wrapping multiple validation errors
// returned by ParticipantTracks.ValidateAll() if the designated constraints
// aren't met.
type ParticipantTracksMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ParticipantTracksMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ParticipantTracksMultiError) AllErrors() []error { return m }

// ParticipantTracksValidationError is the validation error returned by
// ParticipantTracks.Validate if the designated constraints aren't met.
type ParticipantTracksValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ParticipantTracksValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ParticipantTracksValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ParticipantTracksValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ParticipantTracksValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ParticipantTracksValidationError) ErrorName() string {
	return "ParticipantTracksValidationError"
}

// Error satisfies the builtin error interface
func (e ParticipantTracksValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sParticipantTracks.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ParticipantTracksValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ParticipantTracksValidationError{}

// Validate checks the field values on ServerInfo with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ServerInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ServerInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ServerInfoMultiError, or
// nil if none found.
func (m *ServerInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *ServerInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Edition

	// no validation rules for Version

	// no validation rules for Protocol

	// no validation rules for Region

	// no validation rules for NodeId

	// no validation rules for DebugInfo

	// no validation rules for AgentProtocol

	if len(errors) > 0 {
		return ServerInfoMultiError(errors)
	}

	return nil
}

// ServerInfoMultiError is an error wrapping multiple validation errors
// returned by ServerInfo.ValidateAll() if the designated constraints aren't met.
type ServerInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ServerInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ServerInfoMultiError) AllErrors() []error { return m }

// ServerInfoValidationError is the validation error returned by
// ServerInfo.Validate if the designated constraints aren't met.
type ServerInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ServerInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ServerInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ServerInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ServerInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ServerInfoValidationError) ErrorName() string { return "ServerInfoValidationError" }

// Error satisfies the builtin error interface
func (e ServerInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sServerInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ServerInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ServerInfoValidationError{}

// Validate checks the field values on ClientInfo with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ClientInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ClientInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ClientInfoMultiError, or
// nil if none found.
func (m *ClientInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *ClientInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Sdk

	// no validation rules for Version

	// no validation rules for Protocol

	// no validation rules for Os

	// no validation rules for OsVersion

	// no validation rules for DeviceModel

	// no validation rules for Browser

	// no validation rules for BrowserVersion

	// no validation rules for Address

	// no validation rules for Network

	if len(errors) > 0 {
		return ClientInfoMultiError(errors)
	}

	return nil
}

// ClientInfoMultiError is an error wrapping multiple validation errors
// returned by ClientInfo.ValidateAll() if the designated constraints aren't met.
type ClientInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ClientInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ClientInfoMultiError) AllErrors() []error { return m }

// ClientInfoValidationError is the validation error returned by
// ClientInfo.Validate if the designated constraints aren't met.
type ClientInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ClientInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ClientInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ClientInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ClientInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ClientInfoValidationError) ErrorName() string { return "ClientInfoValidationError" }

// Error satisfies the builtin error interface
func (e ClientInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sClientInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ClientInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ClientInfoValidationError{}

// Validate checks the field values on ClientConfiguration with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ClientConfiguration) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ClientConfiguration with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ClientConfigurationMultiError, or nil if none found.
func (m *ClientConfiguration) ValidateAll() error {
	return m.validate(true)
}

func (m *ClientConfiguration) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetVideo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ClientConfigurationValidationError{
					field:  "Video",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ClientConfigurationValidationError{
					field:  "Video",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetVideo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ClientConfigurationValidationError{
				field:  "Video",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetScreen()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ClientConfigurationValidationError{
					field:  "Screen",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ClientConfigurationValidationError{
					field:  "Screen",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetScreen()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ClientConfigurationValidationError{
				field:  "Screen",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ResumeConnection

	if all {
		switch v := interface{}(m.GetDisabledCodecs()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ClientConfigurationValidationError{
					field:  "DisabledCodecs",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ClientConfigurationValidationError{
					field:  "DisabledCodecs",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDisabledCodecs()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ClientConfigurationValidationError{
				field:  "DisabledCodecs",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ForceRelay

	if len(errors) > 0 {
		return ClientConfigurationMultiError(errors)
	}

	return nil
}

// ClientConfigurationMultiError is an error wrapping multiple validation
// errors returned by ClientConfiguration.ValidateAll() if the designated
// constraints aren't met.
type ClientConfigurationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ClientConfigurationMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ClientConfigurationMultiError) AllErrors() []error { return m }

// ClientConfigurationValidationError is the validation error returned by
// ClientConfiguration.Validate if the designated constraints aren't met.
type ClientConfigurationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ClientConfigurationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ClientConfigurationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ClientConfigurationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ClientConfigurationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ClientConfigurationValidationError) ErrorName() string {
	return "ClientConfigurationValidationError"
}

// Error satisfies the builtin error interface
func (e ClientConfigurationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sClientConfiguration.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ClientConfigurationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ClientConfigurationValidationError{}

// Validate checks the field values on VideoConfiguration with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *VideoConfiguration) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on VideoConfiguration with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// VideoConfigurationMultiError, or nil if none found.
func (m *VideoConfiguration) ValidateAll() error {
	return m.validate(true)
}

func (m *VideoConfiguration) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for HardwareEncoder

	if len(errors) > 0 {
		return VideoConfigurationMultiError(errors)
	}

	return nil
}

// VideoConfigurationMultiError is an error wrapping multiple validation errors
// returned by VideoConfiguration.ValidateAll() if the designated constraints
// aren't met.
type VideoConfigurationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m VideoConfigurationMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m VideoConfigurationMultiError) AllErrors() []error { return m }

// VideoConfigurationValidationError is the validation error returned by
// VideoConfiguration.Validate if the designated constraints aren't met.
type VideoConfigurationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e VideoConfigurationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e VideoConfigurationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e VideoConfigurationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e VideoConfigurationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e VideoConfigurationValidationError) ErrorName() string {
	return "VideoConfigurationValidationError"
}

// Error satisfies the builtin error interface
func (e VideoConfigurationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sVideoConfiguration.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = VideoConfigurationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = VideoConfigurationValidationError{}

// Validate checks the field values on DisabledCodecs with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DisabledCodecs) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DisabledCodecs with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DisabledCodecsMultiError,
// or nil if none found.
func (m *DisabledCodecs) ValidateAll() error {
	return m.validate(true)
}

func (m *DisabledCodecs) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetCodecs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DisabledCodecsValidationError{
						field:  fmt.Sprintf("Codecs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DisabledCodecsValidationError{
						field:  fmt.Sprintf("Codecs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DisabledCodecsValidationError{
					field:  fmt.Sprintf("Codecs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetPublish() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DisabledCodecsValidationError{
						field:  fmt.Sprintf("Publish[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DisabledCodecsValidationError{
						field:  fmt.Sprintf("Publish[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DisabledCodecsValidationError{
					field:  fmt.Sprintf("Publish[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return DisabledCodecsMultiError(errors)
	}

	return nil
}

// DisabledCodecsMultiError is an error wrapping multiple validation errors
// returned by DisabledCodecs.ValidateAll() if the designated constraints
// aren't met.
type DisabledCodecsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DisabledCodecsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DisabledCodecsMultiError) AllErrors() []error { return m }

// DisabledCodecsValidationError is the validation error returned by
// DisabledCodecs.Validate if the designated constraints aren't met.
type DisabledCodecsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DisabledCodecsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DisabledCodecsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DisabledCodecsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DisabledCodecsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DisabledCodecsValidationError) ErrorName() string { return "DisabledCodecsValidationError" }

// Error satisfies the builtin error interface
func (e DisabledCodecsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDisabledCodecs.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DisabledCodecsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DisabledCodecsValidationError{}

// Validate checks the field values on RTPDrift with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RTPDrift) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RTPDrift with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RTPDriftMultiError, or nil
// if none found.
func (m *RTPDrift) ValidateAll() error {
	return m.validate(true)
}

func (m *RTPDrift) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetStartTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RTPDriftValidationError{
					field:  "StartTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RTPDriftValidationError{
					field:  "StartTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStartTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RTPDriftValidationError{
				field:  "StartTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetEndTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RTPDriftValidationError{
					field:  "EndTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RTPDriftValidationError{
					field:  "EndTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEndTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RTPDriftValidationError{
				field:  "EndTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Duration

	// no validation rules for StartTimestamp

	// no validation rules for EndTimestamp

	// no validation rules for RtpClockTicks

	// no validation rules for DriftSamples

	// no validation rules for DriftMs

	// no validation rules for ClockRate

	if len(errors) > 0 {
		return RTPDriftMultiError(errors)
	}

	return nil
}

// RTPDriftMultiError is an error wrapping multiple validation errors returned
// by RTPDrift.ValidateAll() if the designated constraints aren't met.
type RTPDriftMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RTPDriftMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RTPDriftMultiError) AllErrors() []error { return m }

// RTPDriftValidationError is the validation error returned by
// RTPDrift.Validate if the designated constraints aren't met.
type RTPDriftValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RTPDriftValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RTPDriftValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RTPDriftValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RTPDriftValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RTPDriftValidationError) ErrorName() string { return "RTPDriftValidationError" }

// Error satisfies the builtin error interface
func (e RTPDriftValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRTPDrift.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RTPDriftValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RTPDriftValidationError{}

// Validate checks the field values on RTPStats with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RTPStats) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RTPStats with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RTPStatsMultiError, or nil
// if none found.
func (m *RTPStats) ValidateAll() error {
	return m.validate(true)
}

func (m *RTPStats) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetStartTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RTPStatsValidationError{
					field:  "StartTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RTPStatsValidationError{
					field:  "StartTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStartTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RTPStatsValidationError{
				field:  "StartTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetEndTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RTPStatsValidationError{
					field:  "EndTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RTPStatsValidationError{
					field:  "EndTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEndTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RTPStatsValidationError{
				field:  "EndTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Duration

	// no validation rules for Packets

	// no validation rules for PacketRate

	// no validation rules for Bytes

	// no validation rules for HeaderBytes

	// no validation rules for Bitrate

	// no validation rules for PacketsLost

	// no validation rules for PacketLossRate

	// no validation rules for PacketLossPercentage

	// no validation rules for PacketsDuplicate

	// no validation rules for PacketDuplicateRate

	// no validation rules for BytesDuplicate

	// no validation rules for HeaderBytesDuplicate

	// no validation rules for BitrateDuplicate

	// no validation rules for PacketsPadding

	// no validation rules for PacketPaddingRate

	// no validation rules for BytesPadding

	// no validation rules for HeaderBytesPadding

	// no validation rules for BitratePadding

	// no validation rules for PacketsOutOfOrder

	// no validation rules for Frames

	// no validation rules for FrameRate

	// no validation rules for JitterCurrent

	// no validation rules for JitterMax

	// no validation rules for GapHistogram

	// no validation rules for Nacks

	// no validation rules for NackAcks

	// no validation rules for NackMisses

	// no validation rules for NackRepeated

	// no validation rules for Plis

	if all {
		switch v := interface{}(m.GetLastPli()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RTPStatsValidationError{
					field:  "LastPli",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RTPStatsValidationError{
					field:  "LastPli",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLastPli()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RTPStatsValidationError{
				field:  "LastPli",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Firs

	if all {
		switch v := interface{}(m.GetLastFir()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RTPStatsValidationError{
					field:  "LastFir",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RTPStatsValidationError{
					field:  "LastFir",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLastFir()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RTPStatsValidationError{
				field:  "LastFir",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RttCurrent

	// no validation rules for RttMax

	// no validation rules for KeyFrames

	if all {
		switch v := interface{}(m.GetLastKeyFrame()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RTPStatsValidationError{
					field:  "LastKeyFrame",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RTPStatsValidationError{
					field:  "LastKeyFrame",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLastKeyFrame()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RTPStatsValidationError{
				field:  "LastKeyFrame",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for LayerLockPlis

	if all {
		switch v := interface{}(m.GetLastLayerLockPli()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RTPStatsValidationError{
					field:  "LastLayerLockPli",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RTPStatsValidationError{
					field:  "LastLayerLockPli",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLastLayerLockPli()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RTPStatsValidationError{
				field:  "LastLayerLockPli",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPacketDrift()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RTPStatsValidationError{
					field:  "PacketDrift",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RTPStatsValidationError{
					field:  "PacketDrift",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPacketDrift()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RTPStatsValidationError{
				field:  "PacketDrift",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetReportDrift()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RTPStatsValidationError{
					field:  "ReportDrift",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RTPStatsValidationError{
					field:  "ReportDrift",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetReportDrift()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RTPStatsValidationError{
				field:  "ReportDrift",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRebasedReportDrift()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RTPStatsValidationError{
					field:  "RebasedReportDrift",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RTPStatsValidationError{
					field:  "RebasedReportDrift",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRebasedReportDrift()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RTPStatsValidationError{
				field:  "RebasedReportDrift",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return RTPStatsMultiError(errors)
	}

	return nil
}

// RTPStatsMultiError is an error wrapping multiple validation errors returned
// by RTPStats.ValidateAll() if the designated constraints aren't met.
type RTPStatsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RTPStatsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RTPStatsMultiError) AllErrors() []error { return m }

// RTPStatsValidationError is the validation error returned by
// RTPStats.Validate if the designated constraints aren't met.
type RTPStatsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RTPStatsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RTPStatsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RTPStatsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RTPStatsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RTPStatsValidationError) ErrorName() string { return "RTPStatsValidationError" }

// Error satisfies the builtin error interface
func (e RTPStatsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRTPStats.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RTPStatsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RTPStatsValidationError{}

// Validate checks the field values on RTPForwarderState with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *RTPForwarderState) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RTPForwarderState with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RTPForwarderStateMultiError, or nil if none found.
func (m *RTPForwarderState) ValidateAll() error {
	return m.validate(true)
}

func (m *RTPForwarderState) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Started

	// no validation rules for ReferenceLayerSpatial

	// no validation rules for PreStartTime

	// no validation rules for ExtFirstTimestamp

	// no validation rules for DummyStartTimestampOffset

	if all {
		switch v := interface{}(m.GetRtpMunger()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RTPForwarderStateValidationError{
					field:  "RtpMunger",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RTPForwarderStateValidationError{
					field:  "RtpMunger",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRtpMunger()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RTPForwarderStateValidationError{
				field:  "RtpMunger",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	switch v := m.CodecMunger.(type) {
	case *RTPForwarderState_Vp8Munger:
		if v == nil {
			err := RTPForwarderStateValidationError{
				field:  "CodecMunger",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetVp8Munger()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RTPForwarderStateValidationError{
						field:  "Vp8Munger",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RTPForwarderStateValidationError{
						field:  "Vp8Munger",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetVp8Munger()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RTPForwarderStateValidationError{
					field:  "Vp8Munger",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return RTPForwarderStateMultiError(errors)
	}

	return nil
}

// RTPForwarderStateMultiError is an error wrapping multiple validation errors
// returned by RTPForwarderState.ValidateAll() if the designated constraints
// aren't met.
type RTPForwarderStateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RTPForwarderStateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RTPForwarderStateMultiError) AllErrors() []error { return m }

// RTPForwarderStateValidationError is the validation error returned by
// RTPForwarderState.Validate if the designated constraints aren't met.
type RTPForwarderStateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RTPForwarderStateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RTPForwarderStateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RTPForwarderStateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RTPForwarderStateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RTPForwarderStateValidationError) ErrorName() string {
	return "RTPForwarderStateValidationError"
}

// Error satisfies the builtin error interface
func (e RTPForwarderStateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRTPForwarderState.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RTPForwarderStateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RTPForwarderStateValidationError{}

// Validate checks the field values on RTPMungerState with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RTPMungerState) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RTPMungerState with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RTPMungerStateMultiError,
// or nil if none found.
func (m *RTPMungerState) ValidateAll() error {
	return m.validate(true)
}

func (m *RTPMungerState) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ExtLastSequenceNumber

	// no validation rules for ExtSecondLastSequenceNumber

	// no validation rules for ExtLastTimestamp

	// no validation rules for ExtSecondLastTimestamp

	// no validation rules for LastMarker

	// no validation rules for SecondLastMarker

	if len(errors) > 0 {
		return RTPMungerStateMultiError(errors)
	}

	return nil
}

// RTPMungerStateMultiError is an error wrapping multiple validation errors
// returned by RTPMungerState.ValidateAll() if the designated constraints
// aren't met.
type RTPMungerStateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RTPMungerStateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RTPMungerStateMultiError) AllErrors() []error { return m }

// RTPMungerStateValidationError is the validation error returned by
// RTPMungerState.Validate if the designated constraints aren't met.
type RTPMungerStateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RTPMungerStateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RTPMungerStateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RTPMungerStateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RTPMungerStateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RTPMungerStateValidationError) ErrorName() string { return "RTPMungerStateValidationError" }

// Error satisfies the builtin error interface
func (e RTPMungerStateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRTPMungerState.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RTPMungerStateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RTPMungerStateValidationError{}

// Validate checks the field values on VP8MungerState with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *VP8MungerState) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on VP8MungerState with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in VP8MungerStateMultiError,
// or nil if none found.
func (m *VP8MungerState) ValidateAll() error {
	return m.validate(true)
}

func (m *VP8MungerState) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ExtLastPictureId

	// no validation rules for PictureIdUsed

	// no validation rules for LastTl0PicIdx

	// no validation rules for Tl0PicIdxUsed

	// no validation rules for TidUsed

	// no validation rules for LastKeyIdx

	// no validation rules for KeyIdxUsed

	if len(errors) > 0 {
		return VP8MungerStateMultiError(errors)
	}

	return nil
}

// VP8MungerStateMultiError is an error wrapping multiple validation errors
// returned by VP8MungerState.ValidateAll() if the designated constraints
// aren't met.
type VP8MungerStateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m VP8MungerStateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m VP8MungerStateMultiError) AllErrors() []error { return m }

// VP8MungerStateValidationError is the validation error returned by
// VP8MungerState.Validate if the designated constraints aren't met.
type VP8MungerStateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e VP8MungerStateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e VP8MungerStateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e VP8MungerStateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e VP8MungerStateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e VP8MungerStateValidationError) ErrorName() string { return "VP8MungerStateValidationError" }

// Error satisfies the builtin error interface
func (e VP8MungerStateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sVP8MungerState.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = VP8MungerStateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = VP8MungerStateValidationError{}

// Validate checks the field values on TimedVersion with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TimedVersion) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TimedVersion with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TimedVersionMultiError, or
// nil if none found.
func (m *TimedVersion) ValidateAll() error {
	return m.validate(true)
}

func (m *TimedVersion) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for UnixMicro

	// no validation rules for Ticks

	if len(errors) > 0 {
		return TimedVersionMultiError(errors)
	}

	return nil
}

// TimedVersionMultiError is an error wrapping multiple validation errors
// returned by TimedVersion.ValidateAll() if the designated constraints aren't met.
type TimedVersionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TimedVersionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TimedVersionMultiError) AllErrors() []error { return m }

// TimedVersionValidationError is the validation error returned by
// TimedVersion.Validate if the designated constraints aren't met.
type TimedVersionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TimedVersionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TimedVersionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TimedVersionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TimedVersionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TimedVersionValidationError) ErrorName() string { return "TimedVersionValidationError" }

// Error satisfies the builtin error interface
func (e TimedVersionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTimedVersion.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TimedVersionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TimedVersionValidationError{}
